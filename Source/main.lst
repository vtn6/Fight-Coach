   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	uart_putchar
  12               	uart_putchar:
  13               	.LFB10:
  14               		.file 1 "trtUart.c"
   1:trtUart.c     **** /*
   2:trtUart.c     ****  * ----------------------------------------------------------------------------
   3:trtUart.c     ****  * "THE BEER-WARE LICENSE" (Revision 42):
   4:trtUart.c     ****  * <joerg@FreeBSD.ORG> wrote this file.  As long as you retain this notice you
   5:trtUart.c     ****  * can do whatever you want with this stuff. If we meet some day, and you think
   6:trtUart.c     ****  * this stuff is worth it, you can buy me a beer in return.        Joerg Wunsch
   7:trtUart.c     ****  * ----------------------------------------------------------------------------
   8:trtUart.c     ****  *
   9:trtUart.c     ****  * Stdio demo, UART implementation
  10:trtUart.c     ****  *
  11:trtUart.c     ****  * $Id: uart.c,v 1.1 2005/12/28 21:38:59 joerg_wunsch Exp $
  12:trtUart.c     ****  *
  13:trtUart.c     ****  * Mod for mega644 Bruce Land Jan2009
  14:trtUart.c     ****  * interrupt-driven getchar added by BL 
  15:trtUart.c     ****  * Circular buffer/ISR driven putchar added by Jeff Melville
  16:trtUart.c     ****  */
  17:trtUart.c     **** 
  18:trtUart.c     **** #define UART_USE_RING_BUF_TX
  19:trtUart.c     **** 
  20:trtUart.c     **** /* CPU frequency */
  21:trtUart.c     **** #define F_CPU 8000000UL
  22:trtUart.c     **** 
  23:trtUart.c     **** // UART baud rate defined in settings
  24:trtUart.c     **** #define UART_BAUD  9600
  25:trtUart.c     **** 
  26:trtUart.c     **** 
  27:trtUart.c     **** #include <stdint.h>
  28:trtUart.c     **** #include <stdio.h>
  29:trtUart.c     **** #include <avr/io.h>
  30:trtUart.c     **** 
  31:trtUart.c     **** //jsm - add for interrupt handling
  32:trtUart.c     **** #include <avr/interrupt.h>
  33:trtUart.c     **** 
  34:trtUart.c     **** #include "trtuart.h"
  35:trtUart.c     **** 
  36:trtUart.c     **** //jsm - create the circular buffer with in/out index
  37:trtUart.c     **** #define TX_BUF_SIZE 200
  38:trtUart.c     **** static volatile unsigned int tx_in;
  39:trtUart.c     **** static volatile unsigned int tx_out;
  40:trtUart.c     **** static volatile char tx_buff [TX_BUF_SIZE];
  41:trtUart.c     **** 
  42:trtUart.c     **** /*
  43:trtUart.c     ****  * Initialize the UART to 9600 Bd, tx/rx, 8N1.
  44:trtUart.c     ****  */
  45:trtUart.c     **** void
  46:trtUart.c     **** trt_uart_init(void)
  47:trtUart.c     **** {
  48:trtUart.c     **** 	#if F_CPU < 2000000UL && defined(U2X)
  49:trtUart.c     **** 	UCSR1A = _BV(U2X);             /* improve baud rate error by using 2x clk */
  50:trtUart.c     **** 	UBRR1L = (F_CPU / (8UL * UART_BAUD)) - 1;
  51:trtUart.c     **** 	#else
  52:trtUart.c     **** 	UBRR1L = (F_CPU / (16UL * UART_BAUD)) - 1;
  53:trtUart.c     **** 	#endif
  54:trtUart.c     **** 
  55:trtUart.c     **** 
  56:trtUart.c     **** 	//Set up circular buffer state variables
  57:trtUart.c     **** 	tx_in = 0;
  58:trtUart.c     **** 	tx_out = 0;
  59:trtUart.c     **** 
  60:trtUart.c     **** 	//enable receive ISR -- added for TRT
  61:trtUart.c     **** 	UCSR1B |= (1<<RXCIE1);
  62:trtUart.c     **** 	UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
  63:trtUart.c     **** 	// UCSR1C 
  64:trtUart.c     **** 	// UCSR1D = 0; //disable RTS and CTS
  65:trtUart.c     **** 	// UCSR1C 
  66:trtUart.c     **** 
  67:trtUart.c     **** 
  68:trtUart.c     **** 
  69:trtUart.c     ****   //disable flow control?
  70:trtUart.c     **** }
  71:trtUart.c     **** 
  72:trtUart.c     **** 
  73:trtUart.c     **** 
  74:trtUart.c     **** ISR( USART1_UDRE_vect )
  75:trtUart.c     **** {
  76:trtUart.c     ****   if( tx_in == tx_out ){		// nothing to send
  77:trtUart.c     ****     UCSR1B &= ~(1 << UDRIE1);	// disable TX interrupt
  78:trtUart.c     ****     //return;
  79:trtUart.c     ****   }
  80:trtUart.c     ****   else {
  81:trtUart.c     ****   	UDR1 = tx_buff[tx_out];
  82:trtUart.c     ****   	tx_out++;
  83:trtUart.c     ****   	if (tx_out == TX_BUF_SIZE) tx_out = 0;
  84:trtUart.c     ****   }
  85:trtUart.c     **** }
  86:trtUart.c     **** 
  87:trtUart.c     **** int uart_putchar(char c, FILE *stream) {
  15               		.loc 1 87 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22               	/* prologue: function */
  23               	/* frame size = 0 */
  24               	/* stack size = 1 */
  25               	.L__stack_usage = 1
  26 0002 C82F      		mov r28,r24
  88:trtUart.c     ****   if (c == '\n') uart_putchar('\r', stream);
  27               		.loc 1 88 0
  28 0004 8A30      		cpi r24,lo8(10)
  29 0006 01F4      		brne .L2
  30               		.loc 1 88 0 is_stmt 0 discriminator 1
  31 0008 8DE0      		ldi r24,lo8(13)
  32               	.LVL1:
  33 000a 0E94 0000 		call uart_putchar
  34               	.LVL2:
  35               	.L2:
  89:trtUart.c     ****   char i = tx_in;
  36               		.loc 1 89 0 is_stmt 1
  37 000e 2091 0000 		lds r18,tx_in
  38 0012 3091 0000 		lds r19,tx_in+1
  39               	.LVL3:
  90:trtUart.c     ****   i++;
  40               		.loc 1 90 0
  41 0016 2F5F      		subi r18,lo8(-(1))
  42               	.LVL4:
  91:trtUart.c     ****   if (i == TX_BUF_SIZE) i = 0;
  43               		.loc 1 91 0
  44 0018 283C      		cpi r18,lo8(-56)
  45 001a 01F4      		brne .L3
  46 001c 20E0      		ldi r18,0
  47               	.LVL5:
  48               	.L3:
  92:trtUart.c     ****   tx_buff[tx_in] = c;
  49               		.loc 1 92 0
  50 001e E091 0000 		lds r30,tx_in
  51 0022 F091 0000 		lds r31,tx_in+1
  52 0026 E050      		subi r30,lo8(-(tx_buff))
  53 0028 F040      		sbci r31,hi8(-(tx_buff))
  54 002a C083      		st Z,r28
  93:trtUart.c     ****   while( i == tx_out);		// until at least one byte free
  55               		.loc 1 93 0
  56 002c 822F      		mov r24,r18
  57 002e 90E0      		ldi r25,0
  58               	.LVL6:
  59               	.L5:
  60               		.loc 1 93 0 is_stmt 0 discriminator 1
  61 0030 2091 0000 		lds r18,tx_out
  62 0034 3091 0000 		lds r19,tx_out+1
  63 0038 8217      		cp r24,r18
  64 003a 9307      		cpc r25,r19
  65 003c 01F0      		breq .L5
  94:trtUart.c     **** 					// tx_out modified by interrupt !
  95:trtUart.c     ****   tx_in = i;
  66               		.loc 1 95 0 is_stmt 1
  67 003e 9093 0000 		sts tx_in+1,r25
  68 0042 8093 0000 		sts tx_in,r24
  96:trtUart.c     ****   UCSR1B |= (1 << UDRIE1);  // enable TX interrupt
  69               		.loc 1 96 0
  70 0046 8091 C900 		lds r24,201
  71               	.LVL7:
  72 004a 8062      		ori r24,lo8(32)
  73 004c 8093 C900 		sts 201,r24
  97:trtUart.c     ****   return 0;
  98:trtUart.c     ****  }
  74               		.loc 1 98 0
  75 0050 80E0      		ldi r24,0
  76 0052 90E0      		ldi r25,0
  77               	/* epilogue start */
  78 0054 CF91      		pop r28
  79               	.LVL8:
  80 0056 0895      		ret
  81               		.cfi_endproc
  82               	.LFE10:
  84               	.global	uart_getchar
  86               	uart_getchar:
  87               	.LFB13:
  99:trtUart.c     **** 
 100:trtUart.c     **** void uart_puts(const char *s)
 101:trtUart.c     **** {
 102:trtUart.c     **** 	while(*s)
 103:trtUart.c     **** 		uart_putchar(*s++,stdout);
 104:trtUart.c     **** 
 105:trtUart.c     **** }
 106:trtUart.c     **** /*
 107:trtUart.c     ****  * Receive a character from the UART Rx.
 108:trtUart.c     ****  *
 109:trtUart.c     ****  * This features a simple line-editor that allows to delete and
 110:trtUart.c     ****  * re-edit the characters entered, until either CR or NL is entered.
 111:trtUart.c     ****  * Printable characters entered will be echoed using uart_putchar().
 112:trtUart.c     ****  *
 113:trtUart.c     ****  * Editing characters:
 114:trtUart.c     ****  *
 115:trtUart.c     ****  * . \b (BS) or \177 (DEL) delete the previous character
 116:trtUart.c     ****  * . ^u kills the entire input buffer
 117:trtUart.c     ****  * . ^w deletes the previous word
 118:trtUart.c     ****  * . ^r sends a CR, and then reprints the buffer
 119:trtUart.c     ****  * . \t will be replaced by a single space
 120:trtUart.c     ****  *
 121:trtUart.c     ****  * All other control characters will be ignored.
 122:trtUart.c     ****  *
 123:trtUart.c     ****  * The internal line buffer is RX_BUFSIZE (80) characters long, which
 124:trtUart.c     ****  * includes the terminating \n (but no terminating \0).  If the buffer
 125:trtUart.c     ****  * is full (i. e., at RX_BUFSIZE-1 characters in order to keep space for
 126:trtUart.c     ****  * the trailing \n), any further input attempts will send a \a to
 127:trtUart.c     ****  * uart_putchar() (BEL character), although line editing is still
 128:trtUart.c     ****  * allowed.
 129:trtUart.c     ****  *
 130:trtUart.c     ****  * Input errors while talking to the UART will cause an immediate
 131:trtUart.c     ****  * return of -1 (error indication).  Notably, this will be caused by a
 132:trtUart.c     ****  * framing error (e. g. serial line "break" condition), by an input
 133:trtUart.c     ****  * overrun, and by a parity error (if parity was enabled and automatic
 134:trtUart.c     ****  * parity recognition is supported by hardware).
 135:trtUart.c     ****  *
 136:trtUart.c     ****  * Successive calls to uart_getchar() will be satisfied from the
 137:trtUart.c     ****  * internal buffer until that buffer is emptied again.
 138:trtUart.c     ****  */
 139:trtUart.c     **** 
 140:trtUart.c     ****  // --- added for TRT ------------
 141:trtUart.c     **** uint8_t trt_rx_c;
 142:trtUart.c     **** 
 143:trtUart.c     **** ISR(USART1_RX_vect) {
 144:trtUart.c     **** 	trt_rx_c = UDR1;
 145:trtUart.c     **** }
 146:trtUart.c     **** // --- end addition --------------
 147:trtUart.c     **** 
 148:trtUart.c     **** int
 149:trtUart.c     **** uart_getchar(FILE *stream)
 150:trtUart.c     **** {
  88               		.loc 1 150 0
  89               		.cfi_startproc
  90               	.LVL9:
  91 0058 EF92      		push r14
  92               	.LCFI1:
  93               		.cfi_def_cfa_offset 3
  94               		.cfi_offset 14, -2
  95 005a FF92      		push r15
  96               	.LCFI2:
  97               		.cfi_def_cfa_offset 4
  98               		.cfi_offset 15, -3
  99 005c 0F93      		push r16
 100               	.LCFI3:
 101               		.cfi_def_cfa_offset 5
 102               		.cfi_offset 16, -4
 103 005e 1F93      		push r17
 104               	.LCFI4:
 105               		.cfi_def_cfa_offset 6
 106               		.cfi_offset 17, -5
 107 0060 CF93      		push r28
 108               	.LCFI5:
 109               		.cfi_def_cfa_offset 7
 110               		.cfi_offset 28, -6
 111 0062 DF93      		push r29
 112               	.LCFI6:
 113               		.cfi_def_cfa_offset 8
 114               		.cfi_offset 29, -7
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 6 */
 118               	.L__stack_usage = 6
 119 0064 8C01      		movw r16,r24
 151:trtUart.c     ****   uint8_t c;
 152:trtUart.c     ****   char *cp, *cp2;
 153:trtUart.c     ****   static char b[RX_BUFSIZE];
 154:trtUart.c     ****   static char *rxp;
 155:trtUart.c     **** 
 156:trtUart.c     ****   if (rxp == 0)
 120               		.loc 1 156 0
 121 0066 8091 0000 		lds r24,rxp.2099
 122 006a 9091 0000 		lds r25,rxp.2099+1
 123               	.LVL10:
 124 006e 892B      		or r24,r25
 125 0070 01F0      		breq .+2
 126 0072 00C0      		rjmp .L9
 127 0074 C0E0      		ldi r28,lo8(b.2098)
 128 0076 D0E0      		ldi r29,hi8(b.2098)
 129               	.L10:
 130               	.LVL11:
 157:trtUart.c     ****     for (cp = b;;)
 158:trtUart.c     ****       {
 159:trtUart.c     **** 	// --- trtWait added instead of loop_until wait
 160:trtUart.c     **** 	if (UCSR1A & _BV(FE1))
 131               		.loc 1 160 0
 132 0078 8091 C800 		lds r24,200
 133 007c 84FD      		sbrc r24,4
 134 007e 00C0      		rjmp .L31
 161:trtUart.c     **** 	  return _FDEV_EOF;
 162:trtUart.c     **** 	if (UCSR1A & _BV(DOR1))
 135               		.loc 1 162 0
 136 0080 8091 C800 		lds r24,200
 137 0084 83FD      		sbrc r24,3
 138 0086 00C0      		rjmp .L34
 163:trtUart.c     **** 	  return _FDEV_ERR;
 164:trtUart.c     **** 	// -- added to take char from ISR ---
 165:trtUart.c     **** 	  c = trt_rx_c ; //c = UDR0; -- CHANGED
 139               		.loc 1 165 0
 140 0088 8091 0000 		lds r24,trt_rx_c
 141               	.LVL12:
 166:trtUart.c     **** 
 167:trtUart.c     **** 	/* behaviour similar to Unix stty ICRNL */
 168:trtUart.c     **** 	if (c == '\r')
 142               		.loc 1 168 0
 143 008c 8D30      		cpi r24,lo8(13)
 144 008e 01F4      		brne .L13
 145               	.L14:
 146               	.LVL13:
 169:trtUart.c     **** 	  c = '\n';
 170:trtUart.c     **** 	if (c == '\n')
 171:trtUart.c     **** 	  {
 172:trtUart.c     **** 	    *cp = c;
 147               		.loc 1 172 0
 148 0090 8AE0      		ldi r24,lo8(10)
 149 0092 8883      		st Y,r24
 173:trtUart.c     **** 	    uart_putchar(c, stream);
 150               		.loc 1 173 0
 151 0094 B801      		movw r22,r16
 152 0096 0E94 0000 		call uart_putchar
 153               	.LVL14:
 174:trtUart.c     **** 	    rxp = b;
 154               		.loc 1 174 0
 155 009a 80E0      		ldi r24,lo8(b.2098)
 156 009c 90E0      		ldi r25,hi8(b.2098)
 157 009e 9093 0000 		sts rxp.2099+1,r25
 158 00a2 8093 0000 		sts rxp.2099,r24
 175:trtUart.c     **** 	    break;
 159               		.loc 1 175 0
 160 00a6 00C0      		rjmp .L9
 161               	.LVL15:
 162               	.L13:
 170:trtUart.c     **** 	if (c == '\n')
 163               		.loc 1 170 0
 164 00a8 8A30      		cpi r24,lo8(10)
 165 00aa 01F0      		breq .L14
 176:trtUart.c     **** 	  }
 177:trtUart.c     **** 	else if (c == '\t')
 166               		.loc 1 177 0
 167 00ac 8930      		cpi r24,lo8(9)
 168 00ae 01F4      		brne .L15
 178:trtUart.c     **** 	  c = ' ';
 169               		.loc 1 178 0
 170 00b0 80E2      		ldi r24,lo8(32)
 171               	.LVL16:
 172               	.L15:
 179:trtUart.c     **** 
 180:trtUart.c     **** 	if ((c >= (uint8_t)' ' && c <= (uint8_t)'\x7e') ||
 173               		.loc 1 180 0
 174 00b2 90EE      		ldi r25,lo8(-32)
 175 00b4 980F      		add r25,r24
 176 00b6 9F35      		cpi r25,lo8(95)
 177 00b8 00F0      		brlo .L16
 178               		.loc 1 180 0 is_stmt 0 discriminator 1
 179 00ba 803A      		cpi r24,lo8(-96)
 180 00bc 00F0      		brlo .L17
 181               	.L16:
 181:trtUart.c     **** 	    c >= (uint8_t)'\xa0')
 182:trtUart.c     **** 	  {
 183:trtUart.c     **** 	    if (cp == b + RX_BUFSIZE - 1)
 182               		.loc 1 183 0 is_stmt 1
 183 00be 90E0      		ldi r25,hi8(b.2098+79)
 184 00c0 C030      		cpi r28,lo8(b.2098+79)
 185 00c2 D907      		cpc r29,r25
 186 00c4 01F4      		brne .L18
 184:trtUart.c     **** 	      uart_putchar('\a', stream);
 187               		.loc 1 184 0
 188 00c6 B801      		movw r22,r16
 189 00c8 87E0      		ldi r24,lo8(7)
 190               	.LVL17:
 191 00ca 0E94 0000 		call uart_putchar
 192               	.LVL18:
 193 00ce 00C0      		rjmp .L10
 194               	.LVL19:
 195               	.L18:
 185:trtUart.c     **** 	    else
 186:trtUart.c     **** 	      {
 187:trtUart.c     **** 		*cp++ = c;
 196               		.loc 1 187 0
 197 00d0 7E01      		movw r14,r28
 198 00d2 EFEF      		ldi r30,-1
 199 00d4 EE1A      		sub r14,r30
 200 00d6 FE0A      		sbc r15,r30
 201               	.LVL20:
 202 00d8 8883      		st Y,r24
 188:trtUart.c     **** 		uart_putchar(c, stream);
 203               		.loc 1 188 0
 204 00da B801      		movw r22,r16
 205 00dc 0E94 0000 		call uart_putchar
 206               	.LVL21:
 187:trtUart.c     **** 		*cp++ = c;
 207               		.loc 1 187 0
 208 00e0 E701      		movw r28,r14
 209 00e2 00C0      		rjmp .L10
 210               	.LVL22:
 211               	.L17:
 189:trtUart.c     **** 	      }
 190:trtUart.c     **** 	    continue;
 191:trtUart.c     **** 	  }
 192:trtUart.c     **** 
 193:trtUart.c     **** 	switch (c)
 212               		.loc 1 193 0
 213 00e4 8231      		cpi r24,lo8(18)
 214 00e6 01F0      		breq .L19
 215 00e8 00F4      		brsh .L20
 216 00ea 8330      		cpi r24,lo8(3)
 217 00ec 01F4      		brne .+2
 218 00ee 00C0      		rjmp .L34
 219 00f0 8830      		cpi r24,lo8(8)
 220 00f2 01F0      		breq .L21
 221 00f4 00C0      		rjmp .L10
 222               	.L20:
 223 00f6 8731      		cpi r24,lo8(23)
 224 00f8 01F4      		brne .+2
 225 00fa 00C0      		rjmp .L24
 226 00fc 8F37      		cpi r24,lo8(127)
 227 00fe 01F0      		breq .L21
 228 0100 8531      		cpi r24,lo8(21)
 229 0102 01F0      		breq .L41
 230 0104 00C0      		rjmp .L10
 231               	.L21:
 194:trtUart.c     **** 	  {
 195:trtUart.c     **** 	  case 'c' & 0x1f:
 196:trtUart.c     **** 	    return -1;
 197:trtUart.c     **** 
 198:trtUart.c     **** 	  case '\b':
 199:trtUart.c     **** 	  case '\x7f':
 200:trtUart.c     **** 	    if (cp > b)
 232               		.loc 1 200 0
 233 0106 F0E0      		ldi r31,hi8(b.2098)
 234 0108 C030      		cpi r28,lo8(b.2098)
 235 010a DF07      		cpc r29,r31
 236 010c 01F0      		breq .+2
 237 010e 00F4      		brsh .+2
 238 0110 00C0      		rjmp .L10
 201:trtUart.c     **** 	      {
 202:trtUart.c     **** 		uart_putchar('\b', stream);
 239               		.loc 1 202 0
 240 0112 B801      		movw r22,r16
 241 0114 88E0      		ldi r24,lo8(8)
 242               	.LVL23:
 243 0116 0E94 0000 		call uart_putchar
 244               	.LVL24:
 203:trtUart.c     **** 		uart_putchar(' ', stream);
 245               		.loc 1 203 0
 246 011a B801      		movw r22,r16
 247 011c 80E2      		ldi r24,lo8(32)
 248 011e 0E94 0000 		call uart_putchar
 249               	.LVL25:
 204:trtUart.c     **** 		uart_putchar('\b', stream);
 250               		.loc 1 204 0
 251 0122 B801      		movw r22,r16
 252 0124 88E0      		ldi r24,lo8(8)
 253 0126 0E94 0000 		call uart_putchar
 254               	.LVL26:
 205:trtUart.c     **** 		cp--;
 255               		.loc 1 205 0
 256 012a 2197      		sbiw r28,1
 257               	.LVL27:
 258 012c 00C0      		rjmp .L10
 259               	.LVL28:
 260               	.L19:
 206:trtUart.c     **** 	      }
 207:trtUart.c     **** 	    break;
 208:trtUart.c     **** 
 209:trtUart.c     **** 	  case 'r' & 0x1f:
 210:trtUart.c     **** 	    uart_putchar('\r', stream);
 261               		.loc 1 210 0
 262 012e B801      		movw r22,r16
 263 0130 8DE0      		ldi r24,lo8(13)
 264               	.LVL29:
 265 0132 0E94 0000 		call uart_putchar
 266               	.LVL30:
 211:trtUart.c     **** 	    for (cp2 = b; cp2 < cp; cp2++)
 267               		.loc 1 211 0
 268 0136 80E0      		ldi r24,lo8(b.2098)
 269 0138 E82E      		mov r14,r24
 270 013a 80E0      		ldi r24,hi8(b.2098)
 271 013c F82E      		mov r15,r24
 272               	.LVL31:
 273               	.L26:
 274               		.loc 1 211 0 is_stmt 0 discriminator 1
 275 013e EC16      		cp r14,r28
 276 0140 FD06      		cpc r15,r29
 277 0142 00F0      		brlo .+2
 278 0144 00C0      		rjmp .L10
 212:trtUart.c     **** 	      uart_putchar(*cp2, stream);
 279               		.loc 1 212 0 is_stmt 1 discriminator 2
 280 0146 B801      		movw r22,r16
 281 0148 F701      		movw r30,r14
 282 014a 8191      		ld r24,Z+
 283 014c 7F01      		movw r14,r30
 284               	.LVL32:
 285 014e 0E94 0000 		call uart_putchar
 286               	.LVL33:
 287 0152 00C0      		rjmp .L26
 288               	.LVL34:
 289               	.L41:
 213:trtUart.c     **** 	    break;
 214:trtUart.c     **** 
 215:trtUart.c     **** 	  case 'u' & 0x1f:
 216:trtUart.c     **** 	    while (cp > b)
 290               		.loc 1 216 0 discriminator 1
 291 0154 F0E0      		ldi r31,hi8(b.2098)
 292 0156 C030      		cpi r28,lo8(b.2098)
 293 0158 DF07      		cpc r29,r31
 294 015a 01F0      		breq .+2
 295 015c 00F4      		brsh .+2
 296 015e 00C0      		rjmp .L10
 217:trtUart.c     **** 	      {
 218:trtUart.c     **** 		uart_putchar('\b', stream);
 297               		.loc 1 218 0
 298 0160 B801      		movw r22,r16
 299 0162 88E0      		ldi r24,lo8(8)
 300 0164 0E94 0000 		call uart_putchar
 301               	.LVL35:
 219:trtUart.c     **** 		uart_putchar(' ', stream);
 302               		.loc 1 219 0
 303 0168 B801      		movw r22,r16
 304 016a 80E2      		ldi r24,lo8(32)
 305 016c 0E94 0000 		call uart_putchar
 306               	.LVL36:
 220:trtUart.c     **** 		uart_putchar('\b', stream);
 307               		.loc 1 220 0
 308 0170 B801      		movw r22,r16
 309 0172 88E0      		ldi r24,lo8(8)
 310 0174 0E94 0000 		call uart_putchar
 311               	.LVL37:
 221:trtUart.c     **** 		cp--;
 312               		.loc 1 221 0
 313 0178 2197      		sbiw r28,1
 314               	.LVL38:
 315 017a 00C0      		rjmp .L41
 316               	.L47:
 222:trtUart.c     **** 	      }
 223:trtUart.c     **** 	    break;
 224:trtUart.c     **** 
 225:trtUart.c     **** 	  case 'w' & 0x1f:
 226:trtUart.c     **** 	    while (cp > b && cp[-1] != ' ')
 317               		.loc 1 226 0 discriminator 2
 318 017c FE01      		movw r30,r28
 319 017e 8291      		ld r24,-Z
 320 0180 7F01      		movw r14,r30
 321 0182 8032      		cpi r24,lo8(32)
 322 0184 01F4      		brne .+2
 323 0186 00C0      		rjmp .L10
 227:trtUart.c     **** 	      {
 228:trtUart.c     **** 		uart_putchar('\b', stream);
 324               		.loc 1 228 0
 325 0188 B801      		movw r22,r16
 326 018a 88E0      		ldi r24,lo8(8)
 327 018c 0E94 0000 		call uart_putchar
 328               	.LVL39:
 229:trtUart.c     **** 		uart_putchar(' ', stream);
 329               		.loc 1 229 0
 330 0190 B801      		movw r22,r16
 331 0192 80E2      		ldi r24,lo8(32)
 332 0194 0E94 0000 		call uart_putchar
 333               	.LVL40:
 230:trtUart.c     **** 		uart_putchar('\b', stream);
 334               		.loc 1 230 0
 335 0198 B801      		movw r22,r16
 336 019a 88E0      		ldi r24,lo8(8)
 337 019c 0E94 0000 		call uart_putchar
 338               	.LVL41:
 231:trtUart.c     **** 		cp--;
 339               		.loc 1 231 0
 340 01a0 E701      		movw r28,r14
 341               	.LVL42:
 342               	.L24:
 226:trtUart.c     **** 	    while (cp > b && cp[-1] != ' ')
 343               		.loc 1 226 0 discriminator 1
 344 01a2 80E0      		ldi r24,hi8(b.2098)
 345 01a4 C030      		cpi r28,lo8(b.2098)
 346 01a6 D807      		cpc r29,r24
 347 01a8 01F0      		breq .+2
 348 01aa 00F4      		brsh .L47
 349 01ac 00C0      		rjmp .L10
 350               	.LVL43:
 351               	.L9:
 232:trtUart.c     **** 	      }
 233:trtUart.c     **** 	    break;
 234:trtUart.c     **** 	  }
 235:trtUart.c     ****       }
 236:trtUart.c     **** 
 237:trtUart.c     ****   c = *rxp++;
 352               		.loc 1 237 0
 353 01ae E091 0000 		lds r30,rxp.2099
 354 01b2 F091 0000 		lds r31,rxp.2099+1
 355 01b6 CF01      		movw r24,r30
 356 01b8 0196      		adiw r24,1
 357 01ba 9093 0000 		sts rxp.2099+1,r25
 358 01be 8093 0000 		sts rxp.2099,r24
 359 01c2 8081      		ld r24,Z
 360               	.LVL44:
 238:trtUart.c     ****   if (c == '\n')
 361               		.loc 1 238 0
 362 01c4 8A30      		cpi r24,lo8(10)
 363 01c6 01F4      		brne .L30
 239:trtUart.c     ****     rxp = 0;
 364               		.loc 1 239 0
 365 01c8 1092 0000 		sts rxp.2099+1,__zero_reg__
 366 01cc 1092 0000 		sts rxp.2099,__zero_reg__
 367               	.L30:
 240:trtUart.c     **** 
 241:trtUart.c     ****   return c;
 368               		.loc 1 241 0
 369 01d0 90E0      		ldi r25,0
 370 01d2 00C0      		rjmp .L12
 371               	.LVL45:
 372               	.L31:
 161:trtUart.c     **** 	  return _FDEV_EOF;
 373               		.loc 1 161 0
 374 01d4 8EEF      		ldi r24,lo8(-2)
 375 01d6 9FEF      		ldi r25,lo8(-1)
 376 01d8 00C0      		rjmp .L12
 377               	.L34:
 196:trtUart.c     **** 	    return -1;
 378               		.loc 1 196 0
 379 01da 8FEF      		ldi r24,lo8(-1)
 380 01dc 9FEF      		ldi r25,lo8(-1)
 381               	.LVL46:
 382               	.L12:
 383               	/* epilogue start */
 242:trtUart.c     **** }
 384               		.loc 1 242 0
 385 01de DF91      		pop r29
 386 01e0 CF91      		pop r28
 387 01e2 1F91      		pop r17
 388 01e4 0F91      		pop r16
 389               	.LVL47:
 390 01e6 FF90      		pop r15
 391 01e8 EF90      		pop r14
 392 01ea 0895      		ret
 393               		.cfi_endproc
 394               	.LFE13:
 396               	.global	trt_uart_init
 398               	trt_uart_init:
 399               	.LFB8:
  47:trtUart.c     **** {
 400               		.loc 1 47 0
 401               		.cfi_startproc
 402               	/* prologue: function */
 403               	/* frame size = 0 */
 404               	/* stack size = 0 */
 405               	.L__stack_usage = 0
  52:trtUart.c     **** 	UBRR1L = (F_CPU / (16UL * UART_BAUD)) - 1;
 406               		.loc 1 52 0
 407 01ec 83E3      		ldi r24,lo8(51)
 408 01ee 8093 CC00 		sts 204,r24
  57:trtUart.c     **** 	tx_in = 0;
 409               		.loc 1 57 0
 410 01f2 1092 0000 		sts tx_in+1,__zero_reg__
 411 01f6 1092 0000 		sts tx_in,__zero_reg__
  58:trtUart.c     **** 	tx_out = 0;
 412               		.loc 1 58 0
 413 01fa 1092 0000 		sts tx_out+1,__zero_reg__
 414 01fe 1092 0000 		sts tx_out,__zero_reg__
  61:trtUart.c     **** 	UCSR1B |= (1<<RXCIE1);
 415               		.loc 1 61 0
 416 0202 E9EC      		ldi r30,lo8(-55)
 417 0204 F0E0      		ldi r31,0
 418 0206 8081      		ld r24,Z
 419 0208 8068      		ori r24,lo8(-128)
 420 020a 8083      		st Z,r24
  62:trtUart.c     **** 	UCSR1B = _BV(TXEN1) | _BV(RXEN1); /* tx/rx enable */
 421               		.loc 1 62 0
 422 020c 88E1      		ldi r24,lo8(24)
 423 020e 8083      		st Z,r24
 424 0210 0895      		ret
 425               		.cfi_endproc
 426               	.LFE8:
 428               	.global	__vector_26
 430               	__vector_26:
 431               	.LFB9:
  75:trtUart.c     **** {
 432               		.loc 1 75 0
 433               		.cfi_startproc
 434 0212 1F92      		push r1
 435               	.LCFI7:
 436               		.cfi_def_cfa_offset 3
 437               		.cfi_offset 1, -2
 438 0214 0F92      		push r0
 439               	.LCFI8:
 440               		.cfi_def_cfa_offset 4
 441               		.cfi_offset 0, -3
 442 0216 0FB6      		in r0,__SREG__
 443 0218 0F92      		push r0
 444 021a 1124      		clr __zero_reg__
 445 021c 2F93      		push r18
 446               	.LCFI9:
 447               		.cfi_def_cfa_offset 5
 448               		.cfi_offset 18, -4
 449 021e 3F93      		push r19
 450               	.LCFI10:
 451               		.cfi_def_cfa_offset 6
 452               		.cfi_offset 19, -5
 453 0220 8F93      		push r24
 454               	.LCFI11:
 455               		.cfi_def_cfa_offset 7
 456               		.cfi_offset 24, -6
 457 0222 9F93      		push r25
 458               	.LCFI12:
 459               		.cfi_def_cfa_offset 8
 460               		.cfi_offset 25, -7
 461 0224 EF93      		push r30
 462               	.LCFI13:
 463               		.cfi_def_cfa_offset 9
 464               		.cfi_offset 30, -8
 465 0226 FF93      		push r31
 466               	.LCFI14:
 467               		.cfi_def_cfa_offset 10
 468               		.cfi_offset 31, -9
 469               	/* prologue: Signal */
 470               	/* frame size = 0 */
 471               	/* stack size = 9 */
 472               	.L__stack_usage = 9
  76:trtUart.c     ****   if( tx_in == tx_out ){		// nothing to send
 473               		.loc 1 76 0
 474 0228 2091 0000 		lds r18,tx_in
 475 022c 3091 0000 		lds r19,tx_in+1
 476 0230 8091 0000 		lds r24,tx_out
 477 0234 9091 0000 		lds r25,tx_out+1
 478 0238 2817      		cp r18,r24
 479 023a 3907      		cpc r19,r25
 480 023c 01F4      		brne .L50
  77:trtUart.c     ****     UCSR1B &= ~(1 << UDRIE1);	// disable TX interrupt
 481               		.loc 1 77 0
 482 023e 8091 C900 		lds r24,201
 483 0242 8F7D      		andi r24,lo8(-33)
 484 0244 8093 C900 		sts 201,r24
 485 0248 00C0      		rjmp .L49
 486               	.L50:
  81:trtUart.c     ****   	UDR1 = tx_buff[tx_out];
 487               		.loc 1 81 0
 488 024a E091 0000 		lds r30,tx_out
 489 024e F091 0000 		lds r31,tx_out+1
 490 0252 E050      		subi r30,lo8(-(tx_buff))
 491 0254 F040      		sbci r31,hi8(-(tx_buff))
 492 0256 8081      		ld r24,Z
 493 0258 8093 CE00 		sts 206,r24
  82:trtUart.c     ****   	tx_out++;
 494               		.loc 1 82 0
 495 025c 8091 0000 		lds r24,tx_out
 496 0260 9091 0000 		lds r25,tx_out+1
 497 0264 0196      		adiw r24,1
 498 0266 9093 0000 		sts tx_out+1,r25
 499 026a 8093 0000 		sts tx_out,r24
  83:trtUart.c     ****   	if (tx_out == TX_BUF_SIZE) tx_out = 0;
 500               		.loc 1 83 0
 501 026e 8091 0000 		lds r24,tx_out
 502 0272 9091 0000 		lds r25,tx_out+1
 503 0276 883C      		cpi r24,-56
 504 0278 9105      		cpc r25,__zero_reg__
 505 027a 01F4      		brne .L49
  83:trtUart.c     ****   	if (tx_out == TX_BUF_SIZE) tx_out = 0;
 506               		.loc 1 83 0 is_stmt 0 discriminator 1
 507 027c 1092 0000 		sts tx_out+1,__zero_reg__
 508 0280 1092 0000 		sts tx_out,__zero_reg__
 509               	.L49:
 510               	/* epilogue start */
  85:trtUart.c     **** }
 511               		.loc 1 85 0 is_stmt 1
 512 0284 FF91      		pop r31
 513 0286 EF91      		pop r30
 514 0288 9F91      		pop r25
 515 028a 8F91      		pop r24
 516 028c 3F91      		pop r19
 517 028e 2F91      		pop r18
 518 0290 0F90      		pop r0
 519 0292 0FBE      		out __SREG__,r0
 520 0294 0F90      		pop r0
 521 0296 1F90      		pop r1
 522 0298 1895      		reti
 523               		.cfi_endproc
 524               	.LFE9:
 526               	.global	uart_puts
 528               	uart_puts:
 529               	.LFB11:
 101:trtUart.c     **** {
 530               		.loc 1 101 0
 531               		.cfi_startproc
 532               	.LVL48:
 533 029a CF93      		push r28
 534               	.LCFI15:
 535               		.cfi_def_cfa_offset 3
 536               		.cfi_offset 28, -2
 537 029c DF93      		push r29
 538               	.LCFI16:
 539               		.cfi_def_cfa_offset 4
 540               		.cfi_offset 29, -3
 541               	/* prologue: function */
 542               	/* frame size = 0 */
 543               	/* stack size = 2 */
 544               	.L__stack_usage = 2
 545 029e EC01      		movw r28,r24
 546               	.LVL49:
 547               	.L53:
 102:trtUart.c     **** 	while(*s)
 548               		.loc 1 102 0 discriminator 1
 549 02a0 8991      		ld r24,Y+
 550               	.LVL50:
 551 02a2 8823      		tst r24
 552 02a4 01F0      		breq .L55
 553               	.LVL51:
 103:trtUart.c     **** 		uart_putchar(*s++,stdout);
 554               		.loc 1 103 0
 555 02a6 6091 0000 		lds r22,__iob+2
 556 02aa 7091 0000 		lds r23,__iob+2+1
 557 02ae 0E94 0000 		call uart_putchar
 558               	.LVL52:
 559 02b2 00C0      		rjmp .L53
 560               	.LVL53:
 561               	.L55:
 562               	/* epilogue start */
 105:trtUart.c     **** }
 563               		.loc 1 105 0
 564 02b4 DF91      		pop r29
 565 02b6 CF91      		pop r28
 566               	.LVL54:
 567 02b8 0895      		ret
 568               		.cfi_endproc
 569               	.LFE11:
 571               	.global	__vector_25
 573               	__vector_25:
 574               	.LFB12:
 143:trtUart.c     **** ISR(USART1_RX_vect) {
 575               		.loc 1 143 0
 576               		.cfi_startproc
 577 02ba 1F92      		push r1
 578               	.LCFI17:
 579               		.cfi_def_cfa_offset 3
 580               		.cfi_offset 1, -2
 581 02bc 0F92      		push r0
 582               	.LCFI18:
 583               		.cfi_def_cfa_offset 4
 584               		.cfi_offset 0, -3
 585 02be 0FB6      		in r0,__SREG__
 586 02c0 0F92      		push r0
 587 02c2 1124      		clr __zero_reg__
 588 02c4 8F93      		push r24
 589               	.LCFI19:
 590               		.cfi_def_cfa_offset 5
 591               		.cfi_offset 24, -4
 592               	/* prologue: Signal */
 593               	/* frame size = 0 */
 594               	/* stack size = 4 */
 595               	.L__stack_usage = 4
 144:trtUart.c     **** 	trt_rx_c = UDR1;
 596               		.loc 1 144 0
 597 02c6 8091 CE00 		lds r24,206
 598 02ca 8093 0000 		sts trt_rx_c,r24
 599               	/* epilogue start */
 145:trtUart.c     **** }
 600               		.loc 1 145 0
 601 02ce 8F91      		pop r24
 602 02d0 0F90      		pop r0
 603 02d2 0FBE      		out __SREG__,r0
 604 02d4 0F90      		pop r0
 605 02d6 1F90      		pop r1
 606 02d8 1895      		reti
 607               		.cfi_endproc
 608               	.LFE12:
 610               	.global	i2c_init
 612               	i2c_init:
 613               	.LFB14:
 614               		.file 2 "twimaster.c"
   1:twimaster.c   **** /*************************************************************************
   2:twimaster.c   **** * Title:    I2C master library using hardware TWI interface
   3:twimaster.c   **** * Author:   Peter Fleury <pfleury@gmx.ch>  http://jump.to/fleury
   4:twimaster.c   **** * File:     $Id: twimaster.c,v 1.3 2005/07/02 11:14:21 Peter Exp $
   5:twimaster.c   **** * Software: AVR-GCC 3.4.3 / avr-libc 1.2.3
   6:twimaster.c   **** * Target:   any AVR device with hardware TWI 
   7:twimaster.c   **** * Usage:    API compatible with I2C Software Library i2cmaster.h
   8:twimaster.c   **** **************************************************************************/
   9:twimaster.c   **** #include <inttypes.h>
  10:twimaster.c   **** #include <compat/twi.h>
  11:twimaster.c   **** 
  12:twimaster.c   **** #include <i2cmaster.h>
  13:twimaster.c   **** 
  14:twimaster.c   **** 
  15:twimaster.c   **** /* define CPU frequency in Mhz here if not defined in Makefile */
  16:twimaster.c   **** #ifndef F_CPU
  17:twimaster.c   **** #define F_CPU 4000000UL
  18:twimaster.c   **** #endif
  19:twimaster.c   **** 
  20:twimaster.c   **** /* I2C clock in Hz */
  21:twimaster.c   **** #define SCL_CLOCK  200000L
  22:twimaster.c   **** 
  23:twimaster.c   **** 
  24:twimaster.c   **** /*************************************************************************
  25:twimaster.c   ****  Initialization of the I2C bus interface. Need to be called only once
  26:twimaster.c   **** *************************************************************************/
  27:twimaster.c   **** void i2c_init(void)
  28:twimaster.c   **** {
 615               		.loc 2 28 0
 616               		.cfi_startproc
 617               	/* prologue: function */
 618               	/* frame size = 0 */
 619               	/* stack size = 0 */
 620               	.L__stack_usage = 0
  29:twimaster.c   ****   /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  30:twimaster.c   ****   
  31:twimaster.c   ****   TWSR = 0;                         /* no prescaler */
 621               		.loc 2 31 0
 622 02da 1092 B900 		sts 185,__zero_reg__
  32:twimaster.c   ****   TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
 623               		.loc 2 32 0
 624 02de 8CE0      		ldi r24,lo8(12)
 625 02e0 8093 B800 		sts 184,r24
 626 02e4 0895      		ret
 627               		.cfi_endproc
 628               	.LFE14:
 630               	.global	i2c_start
 632               	i2c_start:
 633               	.LFB15:
  33:twimaster.c   **** 
  34:twimaster.c   **** }/* i2c_init */
  35:twimaster.c   **** 
  36:twimaster.c   **** 
  37:twimaster.c   **** /*************************************************************************	
  38:twimaster.c   ****   Issues a start condition and sends address and transfer direction.
  39:twimaster.c   ****   return 0 = device accessible, 1= failed to access device
  40:twimaster.c   **** *************************************************************************/
  41:twimaster.c   **** unsigned char i2c_start(unsigned char address)
  42:twimaster.c   **** {
 634               		.loc 2 42 0
 635               		.cfi_startproc
 636               	.LVL55:
 637               	/* prologue: function */
 638               	/* frame size = 0 */
 639               	/* stack size = 0 */
 640               	.L__stack_usage = 0
  43:twimaster.c   ****     uint8_t   twst;
  44:twimaster.c   **** 
  45:twimaster.c   **** 	// send START condition
  46:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 641               		.loc 2 46 0
 642 02e6 94EA      		ldi r25,lo8(-92)
 643 02e8 9093 BC00 		sts 188,r25
 644               	.L60:
  47:twimaster.c   **** 
  48:twimaster.c   **** 	// wait until transmission completed
  49:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 645               		.loc 2 49 0 discriminator 1
 646 02ec 9091 BC00 		lds r25,188
 647 02f0 97FF      		sbrs r25,7
 648 02f2 00C0      		rjmp .L60
  50:twimaster.c   **** 
  51:twimaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits.
  52:twimaster.c   **** 	twst = TW_STATUS & 0xF8;
 649               		.loc 2 52 0
 650 02f4 9091 B900 		lds r25,185
 651 02f8 987F      		andi r25,lo8(-8)
 652               	.LVL56:
  53:twimaster.c   **** 	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 653               		.loc 2 53 0
 654 02fa 9830      		cpi r25,lo8(8)
 655 02fc 01F0      		breq .L61
 656               		.loc 2 53 0 is_stmt 0 discriminator 1
 657 02fe 9031      		cpi r25,lo8(16)
 658 0300 01F4      		brne .L67
 659               	.L61:
 660               	.LVL57:
 661               	.LBB23:
 662               	.LBB24:
  54:twimaster.c   **** 
  55:twimaster.c   **** 	// send device address
  56:twimaster.c   **** 	TWDR = address;
 663               		.loc 2 56 0 is_stmt 1
 664 0302 8093 BB00 		sts 187,r24
  57:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 665               		.loc 2 57 0
 666 0306 84E8      		ldi r24,lo8(-124)
 667               	.LVL58:
 668 0308 8093 BC00 		sts 188,r24
 669               	.LVL59:
 670               	.L64:
  58:twimaster.c   **** 
  59:twimaster.c   **** 	// wail until transmission completed and ACK/NACK has been received
  60:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 671               		.loc 2 60 0
 672 030c 8091 BC00 		lds r24,188
 673 0310 87FF      		sbrs r24,7
 674 0312 00C0      		rjmp .L64
  61:twimaster.c   **** 
  62:twimaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits.
  63:twimaster.c   **** 	twst = TW_STATUS & 0xF8;
 675               		.loc 2 63 0
 676 0314 9091 B900 		lds r25,185
 677               	.LVL60:
 678 0318 987F      		andi r25,lo8(-8)
 679               	.LVL61:
  64:twimaster.c   **** 	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 680               		.loc 2 64 0
 681 031a 9831      		cpi r25,lo8(24)
 682 031c 01F0      		breq .L68
 683 031e 81E0      		ldi r24,lo8(1)
 684 0320 9034      		cpi r25,lo8(64)
 685 0322 01F4      		brne .L62
 686               	.L68:
  65:twimaster.c   **** 
  66:twimaster.c   **** 	return 0;
 687               		.loc 2 66 0
 688 0324 80E0      		ldi r24,0
 689 0326 0895      		ret
 690               	.LVL62:
 691               	.L67:
 692               	.LBE24:
 693               	.LBE23:
  53:twimaster.c   **** 	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 694               		.loc 2 53 0
 695 0328 81E0      		ldi r24,lo8(1)
 696               	.LVL63:
 697               	.L62:
  67:twimaster.c   **** 
  68:twimaster.c   **** }/* i2c_start */
 698               		.loc 2 68 0
 699 032a 0895      		ret
 700               		.cfi_endproc
 701               	.LFE15:
 703               	.global	i2c_start_wait
 705               	i2c_start_wait:
 706               	.LFB16:
  69:twimaster.c   **** 
  70:twimaster.c   **** 
  71:twimaster.c   **** /*************************************************************************
  72:twimaster.c   ****  Issues a start condition and sends address and transfer direction.
  73:twimaster.c   ****  If device is busy, use ack polling to wait until device is ready
  74:twimaster.c   ****  
  75:twimaster.c   ****  Input:   address and transfer direction of I2C device
  76:twimaster.c   **** *************************************************************************/
  77:twimaster.c   **** void i2c_start_wait(unsigned char address)
  78:twimaster.c   **** {
 707               		.loc 2 78 0
 708               		.cfi_startproc
 709               	.LVL64:
 710               	/* prologue: function */
 711               	/* frame size = 0 */
 712               	/* stack size = 0 */
 713               	.L__stack_usage = 0
  79:twimaster.c   ****     uint8_t   twst;
  80:twimaster.c   **** 
  81:twimaster.c   **** 
  82:twimaster.c   ****     while ( 1 )
  83:twimaster.c   ****     {
  84:twimaster.c   **** 	    // send START condition
  85:twimaster.c   **** 	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 714               		.loc 2 85 0
 715 032c 24EA      		ldi r18,lo8(-92)
  86:twimaster.c   ****     
  87:twimaster.c   ****     	// wait until transmission completed
  88:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
  89:twimaster.c   ****     
  90:twimaster.c   ****     	// check value of TWI Status Register. Mask prescaler bits.
  91:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
  92:twimaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
  93:twimaster.c   ****     
  94:twimaster.c   ****     	// send device address
  95:twimaster.c   ****     	TWDR = address;
  96:twimaster.c   ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 716               		.loc 2 96 0
 717 032e 34E8      		ldi r19,lo8(-124)
  97:twimaster.c   ****     
  98:twimaster.c   ****     	// wail until transmission completed
  99:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
 100:twimaster.c   ****     
 101:twimaster.c   ****     	// check value of TWI Status Register. Mask prescaler bits.
 102:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
 103:twimaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 104:twimaster.c   ****     	{    	    
 105:twimaster.c   ****     	    /* device busy, send stop condition to terminate write operation */
 106:twimaster.c   **** 	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 718               		.loc 2 106 0
 719 0330 44E9      		ldi r20,lo8(-108)
 720               	.L74:
  85:twimaster.c   **** 	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 721               		.loc 2 85 0
 722 0332 2093 BC00 		sts 188,r18
 723               	.L73:
  88:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
 724               		.loc 2 88 0 discriminator 1
 725 0336 9091 BC00 		lds r25,188
 726 033a 97FF      		sbrs r25,7
 727 033c 00C0      		rjmp .L73
  91:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
 728               		.loc 2 91 0
 729 033e 9091 B900 		lds r25,185
 730 0342 987F      		andi r25,lo8(-8)
 731               	.LVL65:
  92:twimaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 732               		.loc 2 92 0
 733 0344 9830      		cpi r25,lo8(8)
 734 0346 01F0      		breq .L76
  92:twimaster.c   ****     	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 735               		.loc 2 92 0 is_stmt 0 discriminator 1
 736 0348 9031      		cpi r25,lo8(16)
 737 034a 01F4      		brne .L74
 738               	.L76:
  95:twimaster.c   ****     	TWDR = address;
 739               		.loc 2 95 0 is_stmt 1
 740 034c 8093 BB00 		sts 187,r24
  96:twimaster.c   ****     	TWCR = (1<<TWINT) | (1<<TWEN);
 741               		.loc 2 96 0
 742 0350 3093 BC00 		sts 188,r19
 743               	.LVL66:
 744               	.L79:
  99:twimaster.c   ****     	while(!(TWCR & (1<<TWINT)));
 745               		.loc 2 99 0 discriminator 1
 746 0354 9091 BC00 		lds r25,188
 747 0358 97FF      		sbrs r25,7
 748 035a 00C0      		rjmp .L79
 102:twimaster.c   ****     	twst = TW_STATUS & 0xF8;
 749               		.loc 2 102 0
 750 035c 9091 B900 		lds r25,185
 751 0360 987F      		andi r25,lo8(-8)
 752               	.LVL67:
 103:twimaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 753               		.loc 2 103 0
 754 0362 9032      		cpi r25,lo8(32)
 755 0364 01F0      		breq .L80
 103:twimaster.c   ****     	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 756               		.loc 2 103 0 is_stmt 0 discriminator 1
 757 0366 9835      		cpi r25,lo8(88)
 758 0368 01F4      		brne .L72
 759               	.L80:
 760               		.loc 2 106 0 is_stmt 1
 761 036a 4093 BC00 		sts 188,r20
 762               	.LVL68:
 763               	.L82:
 107:twimaster.c   **** 	        
 108:twimaster.c   **** 	        // wait until stop condition is executed and bus released
 109:twimaster.c   **** 	        while(TWCR & (1<<TWSTO));
 764               		.loc 2 109 0 discriminator 1
 765 036e 9091 BC00 		lds r25,188
 766 0372 94FD      		sbrc r25,4
 767 0374 00C0      		rjmp .L82
 768 0376 00C0      		rjmp .L74
 769               	.LVL69:
 770               	.L72:
 771 0378 0895      		ret
 772               		.cfi_endproc
 773               	.LFE16:
 775               	.global	i2c_rep_start
 777               	i2c_rep_start:
 778               	.LFB17:
 110:twimaster.c   **** 	        
 111:twimaster.c   ****     	    continue;
 112:twimaster.c   ****     	}
 113:twimaster.c   ****     	//if( twst != TW_MT_SLA_ACK) return 1;
 114:twimaster.c   ****     	break;
 115:twimaster.c   ****      }
 116:twimaster.c   **** 
 117:twimaster.c   **** }/* i2c_start_wait */
 118:twimaster.c   **** 
 119:twimaster.c   **** 
 120:twimaster.c   **** /*************************************************************************
 121:twimaster.c   ****  Issues a repeated start condition and sends address and transfer direction 
 122:twimaster.c   **** 
 123:twimaster.c   ****  Input:   address and transfer direction of I2C device
 124:twimaster.c   ****  
 125:twimaster.c   ****  Return:  0 device accessible
 126:twimaster.c   ****           1 failed to access device
 127:twimaster.c   **** *************************************************************************/
 128:twimaster.c   **** unsigned char i2c_rep_start(unsigned char address)
 129:twimaster.c   **** {
 779               		.loc 2 129 0
 780               		.cfi_startproc
 781               	.LVL70:
 782               	/* prologue: function */
 783               	/* frame size = 0 */
 784               	/* stack size = 0 */
 785               	.L__stack_usage = 0
 130:twimaster.c   ****     return i2c_start( address );
 786               		.loc 2 130 0
 787 037a 0C94 0000 		jmp i2c_start
 788               	.LVL71:
 789               		.cfi_endproc
 790               	.LFE17:
 792               	.global	i2c_stop
 794               	i2c_stop:
 795               	.LFB18:
 131:twimaster.c   **** 
 132:twimaster.c   **** }/* i2c_rep_start */
 133:twimaster.c   **** 
 134:twimaster.c   **** 
 135:twimaster.c   **** /*************************************************************************
 136:twimaster.c   ****  Terminates the data transfer and releases the I2C bus
 137:twimaster.c   **** *************************************************************************/
 138:twimaster.c   **** void i2c_stop(void)
 139:twimaster.c   **** {
 796               		.loc 2 139 0
 797               		.cfi_startproc
 798               	/* prologue: function */
 799               	/* frame size = 0 */
 800               	/* stack size = 0 */
 801               	.L__stack_usage = 0
 140:twimaster.c   ****     /* send stop condition */
 141:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 802               		.loc 2 141 0
 803 037e 84E9      		ldi r24,lo8(-108)
 804 0380 8093 BC00 		sts 188,r24
 805               	.L95:
 142:twimaster.c   **** 	
 143:twimaster.c   **** 	// wait until stop condition is executed and bus released
 144:twimaster.c   **** 	while(TWCR & (1<<TWSTO));
 806               		.loc 2 144 0 discriminator 1
 807 0384 8091 BC00 		lds r24,188
 808 0388 84FD      		sbrc r24,4
 809 038a 00C0      		rjmp .L95
 810               	/* epilogue start */
 145:twimaster.c   **** 
 146:twimaster.c   **** }/* i2c_stop */
 811               		.loc 2 146 0
 812 038c 0895      		ret
 813               		.cfi_endproc
 814               	.LFE18:
 816               	.global	i2c_write
 818               	i2c_write:
 819               	.LFB19:
 147:twimaster.c   **** 
 148:twimaster.c   **** 
 149:twimaster.c   **** /*************************************************************************
 150:twimaster.c   ****   Send one byte to I2C device
 151:twimaster.c   ****   
 152:twimaster.c   ****   Input:    byte to be transfered
 153:twimaster.c   ****   Return:   0 write successful 
 154:twimaster.c   ****             1 write failed
 155:twimaster.c   **** *************************************************************************/
 156:twimaster.c   **** unsigned char i2c_write( unsigned char data )
 157:twimaster.c   **** {	
 820               		.loc 2 157 0
 821               		.cfi_startproc
 822               	.LVL72:
 823               	/* prologue: function */
 824               	/* frame size = 0 */
 825               	/* stack size = 0 */
 826               	.L__stack_usage = 0
 158:twimaster.c   ****     uint8_t   twst;
 159:twimaster.c   ****     
 160:twimaster.c   **** 	// send data to the previously addressed device
 161:twimaster.c   **** 	TWDR = data;
 827               		.loc 2 161 0
 828 038e 8093 BB00 		sts 187,r24
 162:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 829               		.loc 2 162 0
 830 0392 84E8      		ldi r24,lo8(-124)
 831               	.LVL73:
 832 0394 8093 BC00 		sts 188,r24
 833               	.LVL74:
 834               	.L98:
 163:twimaster.c   **** 
 164:twimaster.c   **** 	// wait until transmission completed
 165:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 835               		.loc 2 165 0 discriminator 1
 836 0398 8091 BC00 		lds r24,188
 837 039c 87FF      		sbrs r24,7
 838 039e 00C0      		rjmp .L98
 166:twimaster.c   **** 
 167:twimaster.c   **** 	// check value of TWI Status Register. Mask prescaler bits
 168:twimaster.c   **** 	twst = TW_STATUS & 0xF8;
 839               		.loc 2 168 0
 840 03a0 9091 B900 		lds r25,185
 841               	.LVL75:
 842 03a4 987F      		andi r25,lo8(-8)
 843               	.LVL76:
 169:twimaster.c   **** 	if( twst != TW_MT_DATA_ACK) return 1;
 844               		.loc 2 169 0
 845 03a6 81E0      		ldi r24,lo8(1)
 846 03a8 9832      		cpi r25,lo8(40)
 847 03aa 01F4      		brne .L99
 848 03ac 80E0      		ldi r24,0
 849               	.L99:
 170:twimaster.c   **** 	return 0;
 171:twimaster.c   **** 
 172:twimaster.c   **** }/* i2c_write */
 850               		.loc 2 172 0
 851 03ae 0895      		ret
 852               		.cfi_endproc
 853               	.LFE19:
 855               	.global	i2c_readAck
 857               	i2c_readAck:
 858               	.LFB20:
 173:twimaster.c   **** 
 174:twimaster.c   **** 
 175:twimaster.c   **** /*************************************************************************
 176:twimaster.c   ****  Read one byte from the I2C device, request more data from device 
 177:twimaster.c   ****  
 178:twimaster.c   ****  Return:  byte read from I2C device
 179:twimaster.c   **** *************************************************************************/
 180:twimaster.c   **** unsigned char i2c_readAck(void)
 181:twimaster.c   **** {
 859               		.loc 2 181 0
 860               		.cfi_startproc
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
 182:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 865               		.loc 2 182 0
 866 03b0 84EC      		ldi r24,lo8(-60)
 867 03b2 8093 BC00 		sts 188,r24
 868               	.L102:
 183:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));    
 869               		.loc 2 183 0 discriminator 1
 870 03b6 8091 BC00 		lds r24,188
 871 03ba 87FF      		sbrs r24,7
 872 03bc 00C0      		rjmp .L102
 184:twimaster.c   **** 
 185:twimaster.c   ****     return TWDR;
 873               		.loc 2 185 0
 874 03be 8091 BB00 		lds r24,187
 186:twimaster.c   **** 
 187:twimaster.c   **** }/* i2c_readAck */
 875               		.loc 2 187 0
 876 03c2 0895      		ret
 877               		.cfi_endproc
 878               	.LFE20:
 880               	.global	i2c_readNak
 882               	i2c_readNak:
 883               	.LFB21:
 188:twimaster.c   **** 
 189:twimaster.c   **** 
 190:twimaster.c   **** /*************************************************************************
 191:twimaster.c   ****  Read one byte from the I2C device, read is followed by a stop condition 
 192:twimaster.c   ****  
 193:twimaster.c   ****  Return:  byte read from I2C device
 194:twimaster.c   **** *************************************************************************/
 195:twimaster.c   **** unsigned char i2c_readNak(void)
 196:twimaster.c   **** {
 884               		.loc 2 196 0
 885               		.cfi_startproc
 886               	/* prologue: function */
 887               	/* frame size = 0 */
 888               	/* stack size = 0 */
 889               	.L__stack_usage = 0
 197:twimaster.c   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 890               		.loc 2 197 0
 891 03c4 84E8      		ldi r24,lo8(-124)
 892 03c6 8093 BC00 		sts 188,r24
 893               	.L105:
 198:twimaster.c   **** 	while(!(TWCR & (1<<TWINT)));
 894               		.loc 2 198 0 discriminator 1
 895 03ca 8091 BC00 		lds r24,188
 896 03ce 87FF      		sbrs r24,7
 897 03d0 00C0      		rjmp .L105
 199:twimaster.c   **** 	
 200:twimaster.c   ****     return TWDR;
 898               		.loc 2 200 0
 899 03d2 8091 BB00 		lds r24,187
 201:twimaster.c   **** 
 202:twimaster.c   **** }/* i2c_readNak */
 900               		.loc 2 202 0
 901 03d6 0895      		ret
 902               		.cfi_endproc
 903               	.LFE21:
 906               	mpu6050_readBytes.part.1:
 907               	.LFB39:
 908               		.file 3 "mpu6050.c"
   1:mpu6050.c     **** /*
   2:mpu6050.c     **** MPU6050 lib 0x02
   3:mpu6050.c     **** 
   4:mpu6050.c     **** copyright (c) Davide Gironi, 2012
   5:mpu6050.c     **** 
   6:mpu6050.c     **** Released under GPLv3.
   7:mpu6050.c     **** Please refer to LICENSE file for licensing information.
   8:mpu6050.c     **** */
   9:mpu6050.c     **** 
  10:mpu6050.c     **** 
  11:mpu6050.c     **** #include <stdlib.h>
  12:mpu6050.c     **** #include <string.h>
  13:mpu6050.c     **** #include <avr/io.h>
  14:mpu6050.c     **** #include <avr/pgmspace.h>
  15:mpu6050.c     **** #include <avr/interrupt.h>
  16:mpu6050.c     **** #include <util/delay.h>
  17:mpu6050.c     **** 
  18:mpu6050.c     **** #include "mpu6050.h"
  19:mpu6050.c     **** #include "i2cmaster.h"
  20:mpu6050.c     **** #include "twimaster.c"
  21:mpu6050.c     **** #if MPU6050_GETATTITUDE == 1 || MPU6050_GETATTITUDE == 2
  22:mpu6050.c     **** #include <math.h>  //include libm
  23:mpu6050.c     **** #endif
  24:mpu6050.c     **** 
  25:mpu6050.c     **** //path to i2c fleury lib
  26:mpu6050.c     **** #include MPU6050_I2CFLEURYPATH
  27:mpu6050.c     **** 
  28:mpu6050.c     **** volatile uint8_t buffer[14];
  29:mpu6050.c     **** #define clear_bit(address,bit) (address &= ~(1<<bit))
  30:mpu6050.c     **** /*
  31:mpu6050.c     ****  * read bytes from chip register
  32:mpu6050.c     ****  */
  33:mpu6050.c     **** int8_t mpu6050_readBytes(uint8_t regAddr, uint8_t length, uint8_t *data) {
 909               		.loc 3 33 0
 910               		.cfi_startproc
 911               	.LVL77:
 912 03d8 AF92      		push r10
 913               	.LCFI20:
 914               		.cfi_def_cfa_offset 3
 915               		.cfi_offset 10, -2
 916 03da BF92      		push r11
 917               	.LCFI21:
 918               		.cfi_def_cfa_offset 4
 919               		.cfi_offset 11, -3
 920 03dc DF92      		push r13
 921               	.LCFI22:
 922               		.cfi_def_cfa_offset 5
 923               		.cfi_offset 13, -4
 924 03de EF92      		push r14
 925               	.LCFI23:
 926               		.cfi_def_cfa_offset 6
 927               		.cfi_offset 14, -5
 928 03e0 FF92      		push r15
 929               	.LCFI24:
 930               		.cfi_def_cfa_offset 7
 931               		.cfi_offset 15, -6
 932 03e2 0F93      		push r16
 933               	.LCFI25:
 934               		.cfi_def_cfa_offset 8
 935               		.cfi_offset 16, -7
 936 03e4 1F93      		push r17
 937               	.LCFI26:
 938               		.cfi_def_cfa_offset 9
 939               		.cfi_offset 17, -8
 940 03e6 CF93      		push r28
 941               	.LCFI27:
 942               		.cfi_def_cfa_offset 10
 943               		.cfi_offset 28, -9
 944 03e8 DF93      		push r29
 945               	.LCFI28:
 946               		.cfi_def_cfa_offset 11
 947               		.cfi_offset 29, -10
 948 03ea 00D0      		rcall .
 949               	.LCFI29:
 950               		.cfi_def_cfa_offset 13
 951 03ec CDB7      		in r28,__SP_L__
 952 03ee DEB7      		in r29,__SP_H__
 953               	.LCFI30:
 954               		.cfi_def_cfa_register 28
 955               	/* prologue: function */
 956               	/* frame size = 2 */
 957               	/* stack size = 11 */
 958               	.L__stack_usage = 11
 959 03f0 182F      		mov r17,r24
 960 03f2 D62E      		mov r13,r22
  34:mpu6050.c     **** 	uint8_t i = 0;
  35:mpu6050.c     **** 	int8_t count = 0;
  36:mpu6050.c     **** 	if(length > 0) {
  37:mpu6050.c     **** 		//request register
  38:mpu6050.c     **** 		i2c_start(MPU6050_ADDR | I2C_WRITE);
 961               		.loc 3 38 0
 962 03f4 80ED      		ldi r24,lo8(-48)
 963               	.LVL78:
 964 03f6 4983      		std Y+1,r20
 965 03f8 5A83      		std Y+2,r21
 966 03fa 0E94 0000 		call i2c_start
 967               	.LVL79:
  39:mpu6050.c     **** 		i2c_write(regAddr);
 968               		.loc 3 39 0
 969 03fe 812F      		mov r24,r17
 970 0400 0E94 0000 		call i2c_write
 971               	.LVL80:
 972               	.LBB25:
 973               	.LBB26:
 974               		.file 4 "/opt/local/avr/include/util/delay.h"
   1:/opt/local/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/opt/local/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/opt/local/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/opt/local/avr/include/util/delay.h ****    All rights reserved.
   5:/opt/local/avr/include/util/delay.h **** 
   6:/opt/local/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/opt/local/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/opt/local/avr/include/util/delay.h **** 
   9:/opt/local/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/opt/local/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/opt/local/avr/include/util/delay.h **** 
  12:/opt/local/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/opt/local/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/opt/local/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/opt/local/avr/include/util/delay.h ****      distribution.
  16:/opt/local/avr/include/util/delay.h **** 
  17:/opt/local/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/opt/local/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/opt/local/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/opt/local/avr/include/util/delay.h **** 
  21:/opt/local/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/opt/local/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/opt/local/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/opt/local/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/opt/local/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/opt/local/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/opt/local/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/opt/local/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/opt/local/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/opt/local/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/opt/local/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/opt/local/avr/include/util/delay.h **** 
  33:/opt/local/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/opt/local/avr/include/util/delay.h **** 
  35:/opt/local/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/opt/local/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/opt/local/avr/include/util/delay.h **** 
  38:/opt/local/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/opt/local/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/opt/local/avr/include/util/delay.h **** #endif
  41:/opt/local/avr/include/util/delay.h **** 
  42:/opt/local/avr/include/util/delay.h **** #include <inttypes.h>
  43:/opt/local/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/opt/local/avr/include/util/delay.h **** #include <math.h>
  45:/opt/local/avr/include/util/delay.h **** 
  46:/opt/local/avr/include/util/delay.h **** /** \file */
  47:/opt/local/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/opt/local/avr/include/util/delay.h ****     \code
  49:/opt/local/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/opt/local/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/opt/local/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/opt/local/avr/include/util/delay.h ****     \endcode
  53:/opt/local/avr/include/util/delay.h **** 
  54:/opt/local/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/opt/local/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/opt/local/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/opt/local/avr/include/util/delay.h ****     used.
  58:/opt/local/avr/include/util/delay.h **** 
  59:/opt/local/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/opt/local/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/opt/local/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/opt/local/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/opt/local/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/opt/local/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/opt/local/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/opt/local/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/opt/local/avr/include/util/delay.h **** 
  68:/opt/local/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/opt/local/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/opt/local/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/opt/local/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/opt/local/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/opt/local/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/opt/local/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/opt/local/avr/include/util/delay.h ****     routines linked into the application.
  76:/opt/local/avr/include/util/delay.h **** 
  77:/opt/local/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/opt/local/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/opt/local/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/opt/local/avr/include/util/delay.h **** 
  81:/opt/local/avr/include/util/delay.h **** */
  82:/opt/local/avr/include/util/delay.h **** 
  83:/opt/local/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/opt/local/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/opt/local/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/opt/local/avr/include/util/delay.h **** #endif
  87:/opt/local/avr/include/util/delay.h **** 
  88:/opt/local/avr/include/util/delay.h **** #ifndef F_CPU
  89:/opt/local/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/opt/local/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/opt/local/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/opt/local/avr/include/util/delay.h **** #endif
  93:/opt/local/avr/include/util/delay.h **** 
  94:/opt/local/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/opt/local/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/opt/local/avr/include/util/delay.h **** #endif
  97:/opt/local/avr/include/util/delay.h **** 
  98:/opt/local/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/opt/local/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/opt/local/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/opt/local/avr/include/util/delay.h **** #  include <math.h>
 102:/opt/local/avr/include/util/delay.h **** #endif
 103:/opt/local/avr/include/util/delay.h **** 
 104:/opt/local/avr/include/util/delay.h **** /**
 105:/opt/local/avr/include/util/delay.h ****    \ingroup util_delay
 106:/opt/local/avr/include/util/delay.h **** 
 107:/opt/local/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/opt/local/avr/include/util/delay.h **** 
 109:/opt/local/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/opt/local/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/opt/local/avr/include/util/delay.h **** 
 112:/opt/local/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/opt/local/avr/include/util/delay.h **** 
 114:/opt/local/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/opt/local/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/opt/local/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/opt/local/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/opt/local/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/opt/local/avr/include/util/delay.h **** 
 120:/opt/local/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/opt/local/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/opt/local/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/opt/local/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/opt/local/avr/include/util/delay.h **** 
 125:/opt/local/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/opt/local/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/opt/local/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/opt/local/avr/include/util/delay.h **** 
 129:/opt/local/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/opt/local/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/opt/local/avr/include/util/delay.h **** 
 132:/opt/local/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/opt/local/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/opt/local/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/opt/local/avr/include/util/delay.h ****    Also, the backward compatible
 136:/opt/local/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/opt/local/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/opt/local/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/opt/local/avr/include/util/delay.h **** 
 140:/opt/local/avr/include/util/delay.h ****  */
 141:/opt/local/avr/include/util/delay.h **** void
 142:/opt/local/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/opt/local/avr/include/util/delay.h **** {
 144:/opt/local/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/opt/local/avr/include/util/delay.h **** 	double __tmp ; 
 146:/opt/local/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/opt/local/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/opt/local/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/opt/local/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/opt/local/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/opt/local/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/opt/local/avr/include/util/delay.h **** 
 153:/opt/local/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/opt/local/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/opt/local/avr/include/util/delay.h **** 
 156:/opt/local/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/opt/local/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/opt/local/avr/include/util/delay.h **** 
 159:/opt/local/avr/include/util/delay.h **** 	#else
 160:/opt/local/avr/include/util/delay.h **** 		//round up by default
 161:/opt/local/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/opt/local/avr/include/util/delay.h **** 	#endif
 163:/opt/local/avr/include/util/delay.h **** 
 164:/opt/local/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/opt/local/avr/include/util/delay.h **** 
 166:/opt/local/avr/include/util/delay.h **** #else
 167:/opt/local/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/opt/local/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/opt/local/avr/include/util/delay.h **** 		__ticks = 1;
 170:/opt/local/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/opt/local/avr/include/util/delay.h **** 	{
 172:/opt/local/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/opt/local/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/opt/local/avr/include/util/delay.h **** 		while(__ticks)
 175:/opt/local/avr/include/util/delay.h **** 		{
 176:/opt/local/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/opt/local/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/opt/local/avr/include/util/delay.h **** 			__ticks --;
 179:/opt/local/avr/include/util/delay.h **** 		}
 180:/opt/local/avr/include/util/delay.h **** 		return;
 181:/opt/local/avr/include/util/delay.h **** 	}
 182:/opt/local/avr/include/util/delay.h **** 	else
 183:/opt/local/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/opt/local/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/opt/local/avr/include/util/delay.h **** #endif
 186:/opt/local/avr/include/util/delay.h **** }
 187:/opt/local/avr/include/util/delay.h **** 
 188:/opt/local/avr/include/util/delay.h **** /**
 189:/opt/local/avr/include/util/delay.h ****    \ingroup util_delay
 190:/opt/local/avr/include/util/delay.h **** 
 191:/opt/local/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/opt/local/avr/include/util/delay.h **** 
 193:/opt/local/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/opt/local/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/opt/local/avr/include/util/delay.h **** 
 196:/opt/local/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/opt/local/avr/include/util/delay.h **** 
 198:/opt/local/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/opt/local/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/opt/local/avr/include/util/delay.h ****    will not be informed about this case.
 201:/opt/local/avr/include/util/delay.h **** 
 202:/opt/local/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/opt/local/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/opt/local/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/opt/local/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/opt/local/avr/include/util/delay.h ****   
 207:/opt/local/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/opt/local/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/opt/local/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/opt/local/avr/include/util/delay.h **** 
 211:/opt/local/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/opt/local/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/opt/local/avr/include/util/delay.h ****  
 214:/opt/local/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/opt/local/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/opt/local/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/opt/local/avr/include/util/delay.h ****    Also, the backward compatible
 218:/opt/local/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/opt/local/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/opt/local/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/opt/local/avr/include/util/delay.h **** 
 222:/opt/local/avr/include/util/delay.h ****  */
 223:/opt/local/avr/include/util/delay.h **** void
 224:/opt/local/avr/include/util/delay.h **** _delay_us(double __us)
 225:/opt/local/avr/include/util/delay.h **** {
 226:/opt/local/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/opt/local/avr/include/util/delay.h **** 	double __tmp ; 
 228:/opt/local/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/opt/local/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/opt/local/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/opt/local/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/opt/local/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/opt/local/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/opt/local/avr/include/util/delay.h **** 
 235:/opt/local/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/opt/local/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/opt/local/avr/include/util/delay.h **** 
 238:/opt/local/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/opt/local/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/opt/local/avr/include/util/delay.h **** 
 241:/opt/local/avr/include/util/delay.h **** 	#else
 242:/opt/local/avr/include/util/delay.h **** 		//round up by default
 243:/opt/local/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/opt/local/avr/include/util/delay.h **** 	#endif
 245:/opt/local/avr/include/util/delay.h **** 
 246:/opt/local/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 975               		.loc 4 246 0
 976 0404 8AE1      		ldi r24,lo8(26)
 977 0406 8A95      		1: dec r24
 978 0408 01F4      		brne 1b
 979 040a 00C0      		rjmp .
 980               	.LBE26:
 981               	.LBE25:
  40:mpu6050.c     ****         _delay_us(10);
  41:mpu6050.c     **** 		//read data
  42:mpu6050.c     **** 		i2c_start(MPU6050_ADDR | I2C_READ);
 982               		.loc 3 42 0
 983 040c 81ED      		ldi r24,lo8(-47)
 984 040e 0E94 0000 		call i2c_start
 985               	.LVL81:
 986 0412 4981      		ldd r20,Y+1
 987 0414 A42E      		mov r10,r20
 988 0416 5A81      		ldd r21,Y+2
 989 0418 B52E      		mov r11,r21
 990 041a 00E0      		ldi r16,0
 991 041c 10E0      		ldi r17,0
  43:mpu6050.c     **** 		for(i=0; i<length; i++) {
  44:mpu6050.c     **** 			count++;
  45:mpu6050.c     **** 			if(i==length-1)
 992               		.loc 3 45 0
 993 041e ED2C      		mov r14,r13
 994 0420 F12C      		mov r15,__zero_reg__
 995 0422 E1E0      		ldi r30,1
 996 0424 EE1A      		sub r14,r30
 997 0426 F108      		sbc r15,__zero_reg__
 998               	.LVL82:
 999               	.L107:
  43:mpu6050.c     **** 		for(i=0; i<length; i++) {
 1000               		.loc 3 43 0
 1001 0428 0D15      		cp r16,r13
 1002 042a 00F4      		brsh .L112
 1003               	.LVL83:
 1004               		.loc 3 45 0
 1005 042c 0E15      		cp r16,r14
 1006 042e 1F05      		cpc r17,r15
 1007 0430 01F4      		brne .L108
  46:mpu6050.c     **** 				data[i] = i2c_readNak();
 1008               		.loc 3 46 0
 1009 0432 0E94 0000 		call i2c_readNak
 1010               	.LVL84:
 1011 0436 00C0      		rjmp .L111
 1012               	.L108:
  47:mpu6050.c     **** 			else
  48:mpu6050.c     **** 				data[i] = i2c_readAck();
 1013               		.loc 3 48 0
 1014 0438 0E94 0000 		call i2c_readAck
 1015               	.LVL85:
 1016               	.L111:
 1017 043c F501      		movw r30,r10
 1018 043e 8083      		st Z,r24
 1019               	.LVL86:
 1020 0440 0F5F      		subi r16,-1
 1021 0442 1F4F      		sbci r17,-1
 1022               	.LVL87:
 1023 0444 FFEF      		ldi r31,-1
 1024 0446 AF1A      		sub r10,r31
 1025 0448 BF0A      		sbc r11,r31
 1026 044a 00C0      		rjmp .L107
 1027               	.L112:
  49:mpu6050.c     **** 		}
  50:mpu6050.c     **** 		i2c_stop();
 1028               		.loc 3 50 0
 1029 044c 0E94 0000 		call i2c_stop
 1030               	.LVL88:
  51:mpu6050.c     **** 	}
  52:mpu6050.c     **** 	return count;
  53:mpu6050.c     **** }
 1031               		.loc 3 53 0
 1032 0450 8D2D      		mov r24,r13
 1033               	/* epilogue start */
 1034 0452 0F90      		pop __tmp_reg__
 1035 0454 0F90      		pop __tmp_reg__
 1036 0456 DF91      		pop r29
 1037 0458 CF91      		pop r28
 1038 045a 1F91      		pop r17
 1039               	.LVL89:
 1040 045c 0F91      		pop r16
 1041               	.LVL90:
 1042 045e FF90      		pop r15
 1043 0460 EF90      		pop r14
 1044 0462 DF90      		pop r13
 1045               	.LVL91:
 1046 0464 BF90      		pop r11
 1047 0466 AF90      		pop r10
 1048 0468 0895      		ret
 1049               		.cfi_endproc
 1050               	.LFE39:
 1052               	.global	mpu6050_readBytes
 1054               	mpu6050_readBytes:
 1055               	.LFB22:
  33:mpu6050.c     **** int8_t mpu6050_readBytes(uint8_t regAddr, uint8_t length, uint8_t *data) {
 1056               		.loc 3 33 0
 1057               		.cfi_startproc
 1058               	.LVL92:
 1059               	/* prologue: function */
 1060               	/* frame size = 0 */
 1061               	/* stack size = 0 */
 1062               	.L__stack_usage = 0
  36:mpu6050.c     **** 	if(length > 0) {
 1063               		.loc 3 36 0
 1064 046a 6111      		cpse r22,__zero_reg__
 1065 046c 0C94 0000 		jmp mpu6050_readBytes.part.1
 1066               	.LVL93:
 1067               	.L114:
 1068               		.loc 3 53 0
 1069 0470 80E0      		ldi r24,0
 1070               	.LVL94:
 1071 0472 0895      		ret
 1072               		.cfi_endproc
 1073               	.LFE22:
 1075               	.global	mpu6050_readByte
 1077               	mpu6050_readByte:
 1078               	.LFB23:
  54:mpu6050.c     **** 
  55:mpu6050.c     **** /*
  56:mpu6050.c     ****  * read 1 byte from chip register
  57:mpu6050.c     ****  */
  58:mpu6050.c     **** int8_t mpu6050_readByte(uint8_t regAddr, uint8_t *data) {
 1079               		.loc 3 58 0
 1080               		.cfi_startproc
 1081               	.LVL95:
 1082               	/* prologue: function */
 1083               	/* frame size = 0 */
 1084               	/* stack size = 0 */
 1085               	.L__stack_usage = 0
 1086 0474 AB01      		movw r20,r22
 1087               	.LVL96:
 1088               	.LBB33:
 1089               	.LBB34:
 1090 0476 61E0      		ldi r22,lo8(1)
 1091               	.LVL97:
 1092 0478 0C94 0000 		jmp mpu6050_readBytes.part.1
 1093               	.LVL98:
 1094               	.LBE34:
 1095               	.LBE33:
 1096               		.cfi_endproc
 1097               	.LFE23:
 1099               	.global	mpu6050_writeBytes
 1101               	mpu6050_writeBytes:
 1102               	.LFB24:
  59:mpu6050.c     ****     return mpu6050_readBytes(regAddr, 1, data);
  60:mpu6050.c     **** }
  61:mpu6050.c     **** 
  62:mpu6050.c     **** /*
  63:mpu6050.c     ****  * write bytes to chip register
  64:mpu6050.c     ****  */
  65:mpu6050.c     **** void mpu6050_writeBytes(uint8_t regAddr, uint8_t length, uint8_t* data) {
 1103               		.loc 3 65 0
 1104               		.cfi_startproc
 1105               	.LVL99:
 1106               		.loc 3 65 0
 1107 047c EF92      		push r14
 1108               	.LCFI31:
 1109               		.cfi_def_cfa_offset 3
 1110               		.cfi_offset 14, -2
 1111 047e FF92      		push r15
 1112               	.LCFI32:
 1113               		.cfi_def_cfa_offset 4
 1114               		.cfi_offset 15, -3
 1115 0480 0F93      		push r16
 1116               	.LCFI33:
 1117               		.cfi_def_cfa_offset 5
 1118               		.cfi_offset 16, -4
 1119 0482 1F93      		push r17
 1120               	.LCFI34:
 1121               		.cfi_def_cfa_offset 6
 1122               		.cfi_offset 17, -5
 1123 0484 CF93      		push r28
 1124               	.LCFI35:
 1125               		.cfi_def_cfa_offset 7
 1126               		.cfi_offset 28, -6
 1127 0486 DF93      		push r29
 1128               	.LCFI36:
 1129               		.cfi_def_cfa_offset 8
 1130               		.cfi_offset 29, -7
 1131 0488 00D0      		rcall .
 1132               	.LCFI37:
 1133               		.cfi_def_cfa_offset 10
 1134 048a CDB7      		in r28,__SP_L__
 1135 048c DEB7      		in r29,__SP_H__
 1136               	.LCFI38:
 1137               		.cfi_def_cfa_register 28
 1138               	/* prologue: function */
 1139               	/* frame size = 2 */
 1140               	/* stack size = 8 */
 1141               	.L__stack_usage = 8
 1142 048e 082F      		mov r16,r24
 1143 0490 162F      		mov r17,r22
  66:mpu6050.c     **** 	if(length > 0) {
 1144               		.loc 3 66 0
 1145 0492 6623      		tst r22
 1146 0494 01F0      		breq .L116
  67:mpu6050.c     **** 		//write data
  68:mpu6050.c     **** 		i2c_start(MPU6050_ADDR | I2C_WRITE);
 1147               		.loc 3 68 0
 1148 0496 80ED      		ldi r24,lo8(-48)
 1149               	.LVL100:
 1150 0498 4983      		std Y+1,r20
 1151 049a 5A83      		std Y+2,r21
 1152 049c 0E94 0000 		call i2c_start
 1153               	.LVL101:
  69:mpu6050.c     **** 		i2c_write(regAddr); //reg
 1154               		.loc 3 69 0
 1155 04a0 802F      		mov r24,r16
 1156 04a2 0E94 0000 		call i2c_write
 1157               	.LVL102:
 1158 04a6 4981      		ldd r20,Y+1
 1159 04a8 042F      		mov r16,r20
 1160               	.LVL103:
 1161               	.LBB35:
  70:mpu6050.c     **** 		for (uint8_t i = 0; i < length; i++) {
 1162               		.loc 3 70 0
 1163 04aa E42E      		mov r14,r20
 1164 04ac 5A81      		ldd r21,Y+2
 1165 04ae F52E      		mov r15,r21
 1166               	.LVL104:
 1167               	.L118:
 1168 04b0 8E2D      		mov r24,r14
 1169 04b2 801B      		sub r24,r16
 1170               		.loc 3 70 0 is_stmt 0 discriminator 1
 1171 04b4 8117      		cp r24,r17
 1172 04b6 00F4      		brsh .L120
  71:mpu6050.c     **** 			i2c_write((uint8_t) data[i]);
 1173               		.loc 3 71 0 is_stmt 1 discriminator 2
 1174 04b8 F701      		movw r30,r14
 1175 04ba 8191      		ld r24,Z+
 1176 04bc 7F01      		movw r14,r30
 1177               	.LVL105:
 1178 04be 0E94 0000 		call i2c_write
 1179               	.LVL106:
 1180 04c2 00C0      		rjmp .L118
 1181               	.L120:
 1182               	/* epilogue start */
 1183               	.LBE35:
  72:mpu6050.c     **** 		}
  73:mpu6050.c     **** 		i2c_stop();
  74:mpu6050.c     **** 	}
  75:mpu6050.c     **** }
 1184               		.loc 3 75 0
 1185 04c4 0F90      		pop __tmp_reg__
 1186 04c6 0F90      		pop __tmp_reg__
 1187 04c8 DF91      		pop r29
 1188 04ca CF91      		pop r28
 1189 04cc 1F91      		pop r17
 1190               	.LVL107:
 1191 04ce 0F91      		pop r16
 1192 04d0 FF90      		pop r15
 1193 04d2 EF90      		pop r14
 1194               	.LVL108:
  73:mpu6050.c     **** 		i2c_stop();
 1195               		.loc 3 73 0
 1196 04d4 0C94 0000 		jmp i2c_stop
 1197               	.LVL109:
 1198               	.L116:
 1199               	/* epilogue start */
 1200               		.loc 3 75 0
 1201 04d8 0F90      		pop __tmp_reg__
 1202 04da 0F90      		pop __tmp_reg__
 1203 04dc DF91      		pop r29
 1204 04de CF91      		pop r28
 1205 04e0 1F91      		pop r17
 1206               	.LVL110:
 1207 04e2 0F91      		pop r16
 1208               	.LVL111:
 1209 04e4 FF90      		pop r15
 1210 04e6 EF90      		pop r14
 1211 04e8 0895      		ret
 1212               		.cfi_endproc
 1213               	.LFE24:
 1215               	.global	mpu6050_writeByte
 1217               	mpu6050_writeByte:
 1218               	.LFB25:
  76:mpu6050.c     **** 
  77:mpu6050.c     **** /*
  78:mpu6050.c     ****  * write 1 byte to chip register
  79:mpu6050.c     ****  */
  80:mpu6050.c     **** void mpu6050_writeByte(uint8_t regAddr, uint8_t data) {
 1219               		.loc 3 80 0
 1220               		.cfi_startproc
 1221               	.LVL112:
 1222 04ea CF93      		push r28
 1223               	.LCFI39:
 1224               		.cfi_def_cfa_offset 3
 1225               		.cfi_offset 28, -2
 1226 04ec DF93      		push r29
 1227               	.LCFI40:
 1228               		.cfi_def_cfa_offset 4
 1229               		.cfi_offset 29, -3
 1230 04ee 1F92      		push __zero_reg__
 1231               	.LCFI41:
 1232               		.cfi_def_cfa_offset 5
 1233 04f0 CDB7      		in r28,__SP_L__
 1234 04f2 DEB7      		in r29,__SP_H__
 1235               	.LCFI42:
 1236               		.cfi_def_cfa_register 28
 1237               	/* prologue: function */
 1238               	/* frame size = 1 */
 1239               	/* stack size = 3 */
 1240               	.L__stack_usage = 3
 1241 04f4 6983      		std Y+1,r22
  81:mpu6050.c     ****     return mpu6050_writeBytes(regAddr, 1, &data);
 1242               		.loc 3 81 0
 1243 04f6 AE01      		movw r20,r28
 1244 04f8 4F5F      		subi r20,-1
 1245 04fa 5F4F      		sbci r21,-1
 1246 04fc 61E0      		ldi r22,lo8(1)
 1247               	.LVL113:
 1248 04fe 0E94 0000 		call mpu6050_writeBytes
 1249               	.LVL114:
 1250               	/* epilogue start */
  82:mpu6050.c     **** }
 1251               		.loc 3 82 0
 1252 0502 0F90      		pop __tmp_reg__
 1253 0504 DF91      		pop r29
 1254 0506 CF91      		pop r28
 1255               	.LVL115:
 1256 0508 0895      		ret
 1257               		.cfi_endproc
 1258               	.LFE25:
 1261               	mpu6050_writeBits.part.2:
 1262               	.LFB40:
  83:mpu6050.c     **** 
  84:mpu6050.c     **** /*
  85:mpu6050.c     ****  * read bits from chip register
  86:mpu6050.c     ****  */
  87:mpu6050.c     **** int8_t mpu6050_readBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data) {
  88:mpu6050.c     ****     // 01101001 read byte
  89:mpu6050.c     ****     // 76543210 bit numbers
  90:mpu6050.c     ****     //    xxx   args: bitStart=4, length=3
  91:mpu6050.c     ****     //    010   masked
  92:mpu6050.c     ****     //   -> 010 shifted
  93:mpu6050.c     ****     int8_t count = 0;
  94:mpu6050.c     ****     if(length > 0) {
  95:mpu6050.c     **** 		uint8_t b;
  96:mpu6050.c     **** 		if ((count = mpu6050_readByte(regAddr, &b)) != 0) {
  97:mpu6050.c     **** 			uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
  98:mpu6050.c     **** 			b &= mask;
  99:mpu6050.c     **** 			b >>= (bitStart - length + 1);
 100:mpu6050.c     **** 			*data = b;
 101:mpu6050.c     **** 		}
 102:mpu6050.c     ****     }
 103:mpu6050.c     ****     return count;
 104:mpu6050.c     **** }
 105:mpu6050.c     **** 
 106:mpu6050.c     **** /*
 107:mpu6050.c     ****  * read 1 bit from chip register
 108:mpu6050.c     ****  */
 109:mpu6050.c     **** int8_t mpu6050_readBit(uint8_t regAddr, uint8_t bitNum, uint8_t *data) {
 110:mpu6050.c     ****     uint8_t b;
 111:mpu6050.c     ****     uint8_t count = mpu6050_readByte(regAddr, &b);
 112:mpu6050.c     ****     *data = b & (1 << bitNum);
 113:mpu6050.c     ****     return count;
 114:mpu6050.c     **** }
 115:mpu6050.c     **** 
 116:mpu6050.c     **** /*
 117:mpu6050.c     ****  * write bit/bits to chip register
 118:mpu6050.c     ****  */
 119:mpu6050.c     **** void mpu6050_writeBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
 1263               		.loc 3 119 0
 1264               		.cfi_startproc
 1265               	.LVL116:
 1266 050a 0F93      		push r16
 1267               	.LCFI43:
 1268               		.cfi_def_cfa_offset 3
 1269               		.cfi_offset 16, -2
 1270 050c 1F93      		push r17
 1271               	.LCFI44:
 1272               		.cfi_def_cfa_offset 4
 1273               		.cfi_offset 17, -3
 1274 050e CF93      		push r28
 1275               	.LCFI45:
 1276               		.cfi_def_cfa_offset 5
 1277               		.cfi_offset 28, -4
 1278 0510 DF93      		push r29
 1279               	.LCFI46:
 1280               		.cfi_def_cfa_offset 6
 1281               		.cfi_offset 29, -5
 1282 0512 00D0      		rcall .
 1283 0514 1F92      		push __zero_reg__
 1284               	.LCFI47:
 1285               		.cfi_def_cfa_offset 9
 1286 0516 CDB7      		in r28,__SP_L__
 1287 0518 DEB7      		in r29,__SP_H__
 1288               	.LCFI48:
 1289               		.cfi_def_cfa_register 28
 1290               	/* prologue: function */
 1291               	/* frame size = 3 */
 1292               	/* stack size = 7 */
 1293               	.L__stack_usage = 7
 1294 051a 182F      		mov r17,r24
 1295 051c 062F      		mov r16,r22
 1296               	.LBB36:
 120:mpu6050.c     ****     //      010 value to write
 121:mpu6050.c     ****     // 76543210 bit numbers
 122:mpu6050.c     ****     //    xxx   args: bitStart=4, length=3
 123:mpu6050.c     ****     // 00011100 mask byte
 124:mpu6050.c     ****     // 10101111 original value (sample)
 125:mpu6050.c     ****     // 10100011 original & ~mask
 126:mpu6050.c     ****     // 10101011 masked | value
 127:mpu6050.c     **** 	if(length > 0) {
 128:mpu6050.c     **** 		uint8_t b = 0;
 1297               		.loc 3 128 0
 1298 051e 1982      		std Y+1,__zero_reg__
 129:mpu6050.c     **** 		if (mpu6050_readByte(regAddr, &b) != 0) { //get current data
 1299               		.loc 3 129 0
 1300 0520 BE01      		movw r22,r28
 1301               	.LVL117:
 1302 0522 6F5F      		subi r22,-1
 1303 0524 7F4F      		sbci r23,-1
 1304 0526 2B83      		std Y+3,r18
 1305 0528 4A83      		std Y+2,r20
 1306 052a 0E94 0000 		call mpu6050_readByte
 1307               	.LVL118:
 1308 052e 2B81      		ldd r18,Y+3
 1309 0530 4A81      		ldd r20,Y+2
 1310 0532 8823      		tst r24
 1311 0534 01F0      		breq .L123
 1312               	.LBB37:
 130:mpu6050.c     **** 			uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
 1313               		.loc 3 130 0
 1314 0536 602F      		mov r22,r16
 1315 0538 70E0      		ldi r23,0
 1316 053a 641B      		sub r22,r20
 1317 053c 7109      		sbc r23,__zero_reg__
 1318 053e 6F5F      		subi r22,-1
 1319 0540 7F4F      		sbci r23,-1
 1320 0542 E1E0      		ldi r30,lo8(1)
 1321 0544 F0E0      		ldi r31,0
 1322 0546 00C0      		rjmp 2f
 1323               		1:
 1324 0548 EE0F      		lsl r30
 1325 054a FF1F      		rol r31
 1326               		2:
 1327 054c 4A95      		dec r20
 1328 054e 02F4      		brpl 1b
 1329 0550 3197      		sbiw r30,1
 1330 0552 062E      		mov r0,r22
 1331 0554 00C0      		rjmp 2f
 1332               		1:
 1333 0556 EE0F      		lsl r30
 1334               		2:
 1335 0558 0A94      		dec r0
 1336 055a 02F4      		brpl 1b
 1337               	.LVL119:
 131:mpu6050.c     **** 			data <<= (bitStart - length + 1); // shift data into correct position
 1338               		.loc 3 131 0
 1339 055c 00C0      		rjmp 2f
 1340               		1:
 1341 055e 220F      		lsl r18
 1342               		2:
 1343 0560 6A95      		dec r22
 1344 0562 02F4      		brpl 1b
 1345               	.LVL120:
 132:mpu6050.c     **** 			data &= mask; // zero all non-important bits in data
 133:mpu6050.c     **** 			b &= ~(mask); // zero all important bits in existing byte
 1346               		.loc 3 133 0
 1347 0564 6E2F      		mov r22,r30
 1348 0566 6095      		com r22
 1349 0568 8981      		ldd r24,Y+1
 1350 056a 6823      		and r22,r24
 132:mpu6050.c     **** 			data &= mask; // zero all non-important bits in data
 1351               		.loc 3 132 0
 1352 056c E223      		and r30,r18
 1353               	.LVL121:
 134:mpu6050.c     **** 			b |= data; // combine data with existing byte
 1354               		.loc 3 134 0
 1355 056e 6E2B      		or r22,r30
 1356 0570 6983      		std Y+1,r22
 135:mpu6050.c     **** 			mpu6050_writeByte(regAddr, b);
 1357               		.loc 3 135 0
 1358 0572 812F      		mov r24,r17
 1359 0574 0E94 0000 		call mpu6050_writeByte
 1360               	.LVL122:
 1361               	.L123:
 1362               	.LBE37:
 136:mpu6050.c     **** 		}
 137:mpu6050.c     ****                 clear_bit(PORTD,7); // Pin PD7 is now LOW
 1363               		.loc 3 137 0
 1364 0578 5F98      		cbi 0xb,7
 1365               	/* epilogue start */
 1366               	.LBE36:
 138:mpu6050.c     **** 	}
 139:mpu6050.c     **** }
 1367               		.loc 3 139 0
 1368 057a 0F90      		pop __tmp_reg__
 1369 057c 0F90      		pop __tmp_reg__
 1370 057e 0F90      		pop __tmp_reg__
 1371 0580 DF91      		pop r29
 1372 0582 CF91      		pop r28
 1373 0584 1F91      		pop r17
 1374               	.LVL123:
 1375 0586 0F91      		pop r16
 1376               	.LVL124:
 1377 0588 0895      		ret
 1378               		.cfi_endproc
 1379               	.LFE40:
 1381               	.global	mpu6050_readBits
 1383               	mpu6050_readBits:
 1384               	.LFB26:
  87:mpu6050.c     **** int8_t mpu6050_readBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t *data) {
 1385               		.loc 3 87 0
 1386               		.cfi_startproc
 1387               	.LVL125:
 1388 058a FF92      		push r15
 1389               	.LCFI49:
 1390               		.cfi_def_cfa_offset 3
 1391               		.cfi_offset 15, -2
 1392 058c 0F93      		push r16
 1393               	.LCFI50:
 1394               		.cfi_def_cfa_offset 4
 1395               		.cfi_offset 16, -3
 1396 058e 1F93      		push r17
 1397               	.LCFI51:
 1398               		.cfi_def_cfa_offset 5
 1399               		.cfi_offset 17, -4
 1400 0590 CF93      		push r28
 1401               	.LCFI52:
 1402               		.cfi_def_cfa_offset 6
 1403               		.cfi_offset 28, -5
 1404 0592 DF93      		push r29
 1405               	.LCFI53:
 1406               		.cfi_def_cfa_offset 7
 1407               		.cfi_offset 29, -6
 1408 0594 00D0      		rcall .
 1409               	.LCFI54:
 1410               		.cfi_def_cfa_offset 9
 1411 0596 CDB7      		in r28,__SP_L__
 1412 0598 DEB7      		in r29,__SP_H__
 1413               	.LCFI55:
 1414               		.cfi_def_cfa_register 28
 1415               	/* prologue: function */
 1416               	/* frame size = 2 */
 1417               	/* stack size = 7 */
 1418               	.L__stack_usage = 7
 1419 059a F62E      		mov r15,r22
 1420 059c 8901      		movw r16,r18
 1421               	.LVL126:
  94:mpu6050.c     ****     if(length > 0) {
 1422               		.loc 3 94 0
 1423 059e 4423      		tst r20
 1424 05a0 01F0      		breq .L130
 1425               	.LBB38:
  96:mpu6050.c     **** 		if ((count = mpu6050_readByte(regAddr, &b)) != 0) {
 1426               		.loc 3 96 0
 1427 05a2 BE01      		movw r22,r28
 1428               	.LVL127:
 1429 05a4 6F5F      		subi r22,-1
 1430 05a6 7F4F      		sbci r23,-1
 1431 05a8 4A83      		std Y+2,r20
 1432 05aa 0E94 0000 		call mpu6050_readByte
 1433               	.LVL128:
 1434 05ae 4A81      		ldd r20,Y+2
 1435 05b0 8823      		tst r24
 1436 05b2 01F0      		breq .L128
 1437               	.LBB39:
  97:mpu6050.c     **** 			uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
 1438               		.loc 3 97 0
 1439 05b4 6F2D      		mov r22,r15
 1440 05b6 70E0      		ldi r23,0
 1441 05b8 641B      		sub r22,r20
 1442 05ba 7109      		sbc r23,__zero_reg__
 1443 05bc 6F5F      		subi r22,-1
 1444 05be 7F4F      		sbci r23,-1
 1445 05c0 E1E0      		ldi r30,lo8(1)
 1446 05c2 F0E0      		ldi r31,0
 1447 05c4 00C0      		rjmp 2f
 1448               		1:
 1449 05c6 EE0F      		lsl r30
 1450 05c8 FF1F      		rol r31
 1451               		2:
 1452 05ca 4A95      		dec r20
 1453 05cc 02F4      		brpl 1b
 1454 05ce 3197      		sbiw r30,1
 1455 05d0 062E      		mov r0,r22
 1456 05d2 00C0      		rjmp 2f
 1457               		1:
 1458 05d4 EE0F      		lsl r30
 1459               		2:
 1460 05d6 0A94      		dec r0
 1461 05d8 02F4      		brpl 1b
  98:mpu6050.c     **** 			b &= mask;
 1462               		.loc 3 98 0
 1463 05da 4981      		ldd r20,Y+1
 1464 05dc 4E23      		and r20,r30
  99:mpu6050.c     **** 			b >>= (bitStart - length + 1);
 1465               		.loc 3 99 0
 1466 05de 50E0      		ldi r21,0
 1467 05e0 00C0      		rjmp 2f
 1468               		1:
 1469 05e2 5595      		asr r21
 1470 05e4 4795      		ror r20
 1471               		2:
 1472 05e6 6A95      		dec r22
 1473 05e8 02F4      		brpl 1b
 1474 05ea F801      		movw r30,r16
 1475 05ec 4083      		st Z,r20
 1476 05ee 00C0      		rjmp .L128
 1477               	.LVL129:
 1478               	.L130:
 1479               	.LBE39:
 1480               	.LBE38:
  93:mpu6050.c     ****     int8_t count = 0;
 1481               		.loc 3 93 0
 1482 05f0 80E0      		ldi r24,0
 1483               	.LVL130:
 1484               	.L128:
 1485               	/* epilogue start */
 104:mpu6050.c     **** }
 1486               		.loc 3 104 0
 1487 05f2 0F90      		pop __tmp_reg__
 1488 05f4 0F90      		pop __tmp_reg__
 1489 05f6 DF91      		pop r29
 1490 05f8 CF91      		pop r28
 1491 05fa 1F91      		pop r17
 1492 05fc 0F91      		pop r16
 1493               	.LVL131:
 1494 05fe FF90      		pop r15
 1495               	.LVL132:
 1496 0600 0895      		ret
 1497               		.cfi_endproc
 1498               	.LFE26:
 1500               	.global	mpu6050_readBit
 1502               	mpu6050_readBit:
 1503               	.LFB27:
 109:mpu6050.c     **** int8_t mpu6050_readBit(uint8_t regAddr, uint8_t bitNum, uint8_t *data) {
 1504               		.loc 3 109 0
 1505               		.cfi_startproc
 1506               	.LVL133:
 1507 0602 FF92      		push r15
 1508               	.LCFI56:
 1509               		.cfi_def_cfa_offset 3
 1510               		.cfi_offset 15, -2
 1511 0604 0F93      		push r16
 1512               	.LCFI57:
 1513               		.cfi_def_cfa_offset 4
 1514               		.cfi_offset 16, -3
 1515 0606 1F93      		push r17
 1516               	.LCFI58:
 1517               		.cfi_def_cfa_offset 5
 1518               		.cfi_offset 17, -4
 1519 0608 CF93      		push r28
 1520               	.LCFI59:
 1521               		.cfi_def_cfa_offset 6
 1522               		.cfi_offset 28, -5
 1523 060a DF93      		push r29
 1524               	.LCFI60:
 1525               		.cfi_def_cfa_offset 7
 1526               		.cfi_offset 29, -6
 1527 060c 1F92      		push __zero_reg__
 1528               	.LCFI61:
 1529               		.cfi_def_cfa_offset 8
 1530 060e CDB7      		in r28,__SP_L__
 1531 0610 DEB7      		in r29,__SP_H__
 1532               	.LCFI62:
 1533               		.cfi_def_cfa_register 28
 1534               	/* prologue: function */
 1535               	/* frame size = 1 */
 1536               	/* stack size = 6 */
 1537               	.L__stack_usage = 6
 1538 0612 F62E      		mov r15,r22
 1539 0614 8A01      		movw r16,r20
 111:mpu6050.c     ****     uint8_t count = mpu6050_readByte(regAddr, &b);
 1540               		.loc 3 111 0
 1541 0616 BE01      		movw r22,r28
 1542               	.LVL134:
 1543 0618 6F5F      		subi r22,-1
 1544 061a 7F4F      		sbci r23,-1
 1545 061c 0E94 0000 		call mpu6050_readByte
 1546               	.LVL135:
 112:mpu6050.c     ****     *data = b & (1 << bitNum);
 1547               		.loc 3 112 0
 1548 0620 21E0      		ldi r18,lo8(1)
 1549 0622 30E0      		ldi r19,0
 1550 0624 00C0      		rjmp 2f
 1551               		1:
 1552 0626 220F      		lsl r18
 1553               		2:
 1554 0628 FA94      		dec r15
 1555 062a 02F4      		brpl 1b
 1556 062c 9981      		ldd r25,Y+1
 1557 062e 9223      		and r25,r18
 1558 0630 F801      		movw r30,r16
 1559 0632 9083      		st Z,r25
 1560               	/* epilogue start */
 114:mpu6050.c     **** }
 1561               		.loc 3 114 0
 1562 0634 0F90      		pop __tmp_reg__
 1563 0636 DF91      		pop r29
 1564 0638 CF91      		pop r28
 1565 063a 1F91      		pop r17
 1566 063c 0F91      		pop r16
 1567               	.LVL136:
 1568 063e FF90      		pop r15
 1569               	.LVL137:
 1570 0640 0895      		ret
 1571               		.cfi_endproc
 1572               	.LFE27:
 1574               	.global	mpu6050_writeBits
 1576               	mpu6050_writeBits:
 1577               	.LFB28:
 119:mpu6050.c     **** void mpu6050_writeBits(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
 1578               		.loc 3 119 0
 1579               		.cfi_startproc
 1580               	.LVL138:
 1581               	/* prologue: function */
 1582               	/* frame size = 0 */
 1583               	/* stack size = 0 */
 1584               	.L__stack_usage = 0
 127:mpu6050.c     **** 	if(length > 0) {
 1585               		.loc 3 127 0
 1586 0642 4111      		cpse r20,__zero_reg__
 1587 0644 0C94 0000 		jmp mpu6050_writeBits.part.2
 1588               	.LVL139:
 1589               	.L135:
 1590 0648 0895      		ret
 1591               		.cfi_endproc
 1592               	.LFE28:
 1594               	.global	mpu6050_writeBit
 1596               	mpu6050_writeBit:
 1597               	.LFB29:
 140:mpu6050.c     **** 
 141:mpu6050.c     **** /*
 142:mpu6050.c     ****  * write one bit to chip register
 143:mpu6050.c     ****  */
 144:mpu6050.c     **** void mpu6050_writeBit(uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 1598               		.loc 3 144 0
 1599               		.cfi_startproc
 1600               	.LVL140:
 1601 064a 0F93      		push r16
 1602               	.LCFI63:
 1603               		.cfi_def_cfa_offset 3
 1604               		.cfi_offset 16, -2
 1605 064c 1F93      		push r17
 1606               	.LCFI64:
 1607               		.cfi_def_cfa_offset 4
 1608               		.cfi_offset 17, -3
 1609 064e CF93      		push r28
 1610               	.LCFI65:
 1611               		.cfi_def_cfa_offset 5
 1612               		.cfi_offset 28, -4
 1613 0650 DF93      		push r29
 1614               	.LCFI66:
 1615               		.cfi_def_cfa_offset 6
 1616               		.cfi_offset 29, -5
 1617 0652 00D0      		rcall .
 1618               	.LCFI67:
 1619               		.cfi_def_cfa_offset 8
 1620 0654 CDB7      		in r28,__SP_L__
 1621 0656 DEB7      		in r29,__SP_H__
 1622               	.LCFI68:
 1623               		.cfi_def_cfa_register 28
 1624               	/* prologue: function */
 1625               	/* frame size = 2 */
 1626               	/* stack size = 6 */
 1627               	.L__stack_usage = 6
 1628 0658 182F      		mov r17,r24
 1629 065a 062F      		mov r16,r22
 145:mpu6050.c     ****     uint8_t b;
 146:mpu6050.c     ****     mpu6050_readByte(regAddr, &b);
 1630               		.loc 3 146 0
 1631 065c BE01      		movw r22,r28
 1632               	.LVL141:
 1633 065e 6F5F      		subi r22,-1
 1634 0660 7F4F      		sbci r23,-1
 1635 0662 4A83      		std Y+2,r20
 1636 0664 0E94 0000 		call mpu6050_readByte
 1637               	.LVL142:
 1638 0668 8981      		ldd r24,Y+1
 147:mpu6050.c     ****     b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 1639               		.loc 3 147 0
 1640 066a 4A81      		ldd r20,Y+2
 1641 066c 21E0      		ldi r18,lo8(1)
 1642 066e 30E0      		ldi r19,0
 1643 0670 002E      		mov r0,r16
 1644 0672 00C0      		rjmp 2f
 1645               		1:
 1646 0674 220F      		lsl r18
 1647               		2:
 1648 0676 0A94      		dec r0
 1649 0678 02F4      		brpl 1b
 1650 067a 4423      		tst r20
 1651 067c 01F0      		breq .L138
 1652               		.loc 3 147 0 is_stmt 0 discriminator 1
 1653 067e 682F      		mov r22,r24
 1654 0680 622B      		or r22,r18
 1655 0682 00C0      		rjmp .L139
 1656               	.L138:
 1657               		.loc 3 147 0 discriminator 2
 1658 0684 622F      		mov r22,r18
 1659 0686 6095      		com r22
 1660 0688 6823      		and r22,r24
 1661               	.L139:
 1662               		.loc 3 147 0 discriminator 3
 1663 068a 6983      		std Y+1,r22
 148:mpu6050.c     ****     mpu6050_writeByte(regAddr, b);
 1664               		.loc 3 148 0 is_stmt 1 discriminator 3
 1665 068c 812F      		mov r24,r17
 1666 068e 0E94 0000 		call mpu6050_writeByte
 1667               	.LVL143:
 1668               	/* epilogue start */
 149:mpu6050.c     **** }
 1669               		.loc 3 149 0 discriminator 3
 1670 0692 0F90      		pop __tmp_reg__
 1671 0694 0F90      		pop __tmp_reg__
 1672 0696 DF91      		pop r29
 1673 0698 CF91      		pop r28
 1674 069a 1F91      		pop r17
 1675               	.LVL144:
 1676 069c 0F91      		pop r16
 1677               	.LVL145:
 1678 069e 0895      		ret
 1679               		.cfi_endproc
 1680               	.LFE29:
 1682               	.global	mpu6050_setSleepDisabled
 1684               	mpu6050_setSleepDisabled:
 1685               	.LFB30:
 150:mpu6050.c     **** 
 151:mpu6050.c     **** #if MPU6050_GETATTITUDE == 2
 152:mpu6050.c     **** /*
 153:mpu6050.c     ****  * write word/words to chip register
 154:mpu6050.c     ****  */
 155:mpu6050.c     **** void mpu6050_writeWords(uint8_t regAddr, uint8_t length, uint16_t* data) {
 156:mpu6050.c     **** 	if(length > 0) {
 157:mpu6050.c     **** 		uint8_t i = 0;
 158:mpu6050.c     **** 		//write data
 159:mpu6050.c     **** 		i2c_start(MPU6050_ADDR | I2C_WRITE);
 160:mpu6050.c     **** 		i2c_write(regAddr); //reg
 161:mpu6050.c     **** 		for (i = 0; i < length * 2; i++) {
 162:mpu6050.c     **** 			i2c_write((uint8_t)(data[i++] >> 8)); // send MSB
 163:mpu6050.c     **** 			i2c_write((uint8_t)data[i]);          // send LSB
 164:mpu6050.c     **** 		}
 165:mpu6050.c     **** 		i2c_stop();
 166:mpu6050.c     **** 	}
 167:mpu6050.c     **** }
 168:mpu6050.c     **** 
 169:mpu6050.c     **** /*
 170:mpu6050.c     ****  * set a chip memory bank
 171:mpu6050.c     ****  */
 172:mpu6050.c     **** void mpu6050_setMemoryBank(uint8_t bank, uint8_t prefetchEnabled, uint8_t userBank) {
 173:mpu6050.c     ****     bank &= 0x1F;
 174:mpu6050.c     ****     if (userBank) bank |= 0x20;
 175:mpu6050.c     ****     if (prefetchEnabled) bank |= 0x40;
 176:mpu6050.c     ****     mpu6050_writeByte(MPU6050_RA_BANK_SEL, bank);
 177:mpu6050.c     **** }
 178:mpu6050.c     **** 
 179:mpu6050.c     **** /*
 180:mpu6050.c     ****  * set memory start address
 181:mpu6050.c     ****  */
 182:mpu6050.c     **** void mpu6050_setMemoryStartAddress(uint8_t address) {
 183:mpu6050.c     **** 	mpu6050_writeByte(MPU6050_RA_MEM_START_ADDR, address);
 184:mpu6050.c     **** }
 185:mpu6050.c     **** 
 186:mpu6050.c     **** /*
 187:mpu6050.c     ****  * read a memory block
 188:mpu6050.c     ****  */
 189:mpu6050.c     **** void mpu6050_readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {
 190:mpu6050.c     **** 	mpu6050_setMemoryBank(bank, 0, 0);
 191:mpu6050.c     **** 	mpu6050_setMemoryStartAddress(address);
 192:mpu6050.c     ****     uint8_t chunkSize;
 193:mpu6050.c     ****     for (uint16_t i = 0; i < dataSize;) {
 194:mpu6050.c     ****         // determine correct chunk size according to bank position and data size
 195:mpu6050.c     ****         chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;
 196:mpu6050.c     **** 
 197:mpu6050.c     ****         // make sure we don't go past the data size
 198:mpu6050.c     ****         if (i + chunkSize > dataSize) chunkSize = dataSize - i;
 199:mpu6050.c     **** 
 200:mpu6050.c     ****         // make sure this chunk doesn't go past the bank boundary (256 bytes)
 201:mpu6050.c     ****         if (chunkSize > 256 - address) chunkSize = 256 - address;
 202:mpu6050.c     **** 
 203:mpu6050.c     ****         // read the chunk of data as specified
 204:mpu6050.c     ****         mpu6050_readBytes(MPU6050_RA_MEM_R_W, chunkSize, data + i);
 205:mpu6050.c     **** 
 206:mpu6050.c     ****         // increase byte index by [chunkSize]
 207:mpu6050.c     ****         i += chunkSize;
 208:mpu6050.c     **** 
 209:mpu6050.c     ****         // uint8_t automatically wraps to 0 at 256
 210:mpu6050.c     ****         address += chunkSize;
 211:mpu6050.c     **** 
 212:mpu6050.c     ****         // if we aren't done, update bank (if necessary) and address
 213:mpu6050.c     ****         if (i < dataSize) {
 214:mpu6050.c     ****             if (address == 0) bank++;
 215:mpu6050.c     ****             mpu6050_setMemoryBank(bank, 0, 0);
 216:mpu6050.c     ****             mpu6050_setMemoryStartAddress(address);
 217:mpu6050.c     ****         }
 218:mpu6050.c     ****     }
 219:mpu6050.c     **** }
 220:mpu6050.c     **** 
 221:mpu6050.c     **** /*
 222:mpu6050.c     ****  * write a memory block
 223:mpu6050.c     ****  */
 224:mpu6050.c     **** uint8_t mpu6050_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t addr
 225:mpu6050.c     **** 	mpu6050_setMemoryBank(bank, 0, 0);
 226:mpu6050.c     **** 	mpu6050_setMemoryStartAddress(address);
 227:mpu6050.c     ****     uint8_t chunkSize;
 228:mpu6050.c     ****     uint8_t *verifyBuffer = 0;
 229:mpu6050.c     ****     uint8_t *progBuffer = 0;
 230:mpu6050.c     ****     uint16_t i;
 231:mpu6050.c     ****     uint8_t j;
 232:mpu6050.c     ****     if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
 233:mpu6050.c     ****     if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
 234:mpu6050.c     ****     for (i = 0; i < dataSize;) {
 235:mpu6050.c     ****         // determine correct chunk size according to bank position and data size
 236:mpu6050.c     ****         chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;
 237:mpu6050.c     **** 
 238:mpu6050.c     ****         // make sure we don't go past the data size
 239:mpu6050.c     ****         if (i + chunkSize > dataSize) chunkSize = dataSize - i;
 240:mpu6050.c     **** 
 241:mpu6050.c     ****         // make sure this chunk doesn't go past the bank boundary (256 bytes)
 242:mpu6050.c     ****         if (chunkSize > 256 - address) chunkSize = 256 - address;
 243:mpu6050.c     **** 
 244:mpu6050.c     ****         if (useProgMem) {
 245:mpu6050.c     ****             // write the chunk of data as specified
 246:mpu6050.c     ****             for (j = 0; j < chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);
 247:mpu6050.c     ****         } else {
 248:mpu6050.c     ****             // write the chunk of data as specified
 249:mpu6050.c     ****             progBuffer = (uint8_t *)data + i;
 250:mpu6050.c     ****         }
 251:mpu6050.c     **** 
 252:mpu6050.c     ****         mpu6050_writeBytes(MPU6050_RA_MEM_R_W, chunkSize, progBuffer);
 253:mpu6050.c     **** 
 254:mpu6050.c     ****         // verify data if needed
 255:mpu6050.c     ****         if (verify && verifyBuffer) {
 256:mpu6050.c     ****         	mpu6050_setMemoryBank(bank, 0, 0);
 257:mpu6050.c     ****             mpu6050_setMemoryStartAddress(address);
 258:mpu6050.c     ****             mpu6050_readBytes(MPU6050_RA_MEM_R_W, chunkSize, verifyBuffer);
 259:mpu6050.c     ****             if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {
 260:mpu6050.c     ****                 free(verifyBuffer);
 261:mpu6050.c     ****                 if (useProgMem) free(progBuffer);
 262:mpu6050.c     ****                 return 0; // uh oh.
 263:mpu6050.c     ****             }
 264:mpu6050.c     ****         }
 265:mpu6050.c     **** 
 266:mpu6050.c     ****         // increase byte index by [chunkSize]
 267:mpu6050.c     ****         i += chunkSize;
 268:mpu6050.c     **** 
 269:mpu6050.c     ****         // uint8_t automatically wraps to 0 at 256
 270:mpu6050.c     ****         address += chunkSize;
 271:mpu6050.c     **** 
 272:mpu6050.c     ****         // if we aren't done, update bank (if necessary) and address
 273:mpu6050.c     ****         if (i < dataSize) {
 274:mpu6050.c     ****             if (address == 0) bank++;
 275:mpu6050.c     ****             mpu6050_setMemoryBank(bank, 0, 0);
 276:mpu6050.c     ****             mpu6050_setMemoryStartAddress(address);
 277:mpu6050.c     ****         }
 278:mpu6050.c     ****     }
 279:mpu6050.c     ****     if (verify) free(verifyBuffer);
 280:mpu6050.c     ****     if (useProgMem) free(progBuffer);
 281:mpu6050.c     ****     return 1;
 282:mpu6050.c     **** }
 283:mpu6050.c     **** 
 284:mpu6050.c     **** /*
 285:mpu6050.c     ****  * write a dmp configuration set
 286:mpu6050.c     ****  */
 287:mpu6050.c     **** uint8_t mpu6050_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, uint8_t useProgMem
 288:mpu6050.c     ****     uint8_t *progBuffer = 0;
 289:mpu6050.c     ****     uint8_t success, special;
 290:mpu6050.c     ****     uint16_t i, j;
 291:mpu6050.c     ****     if (useProgMem) {
 292:mpu6050.c     ****         progBuffer = (uint8_t *)malloc(8); // assume 8-byte blocks, realloc later if necessary
 293:mpu6050.c     ****     }
 294:mpu6050.c     **** 
 295:mpu6050.c     ****     // config set data is a long string of blocks with the following structure:
 296:mpu6050.c     ****     // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
 297:mpu6050.c     ****     uint8_t bank, offset, length;
 298:mpu6050.c     ****     for (i = 0; i < dataSize;) {
 299:mpu6050.c     ****         if (useProgMem) {
 300:mpu6050.c     ****             bank = pgm_read_byte(data + i++);
 301:mpu6050.c     ****             offset = pgm_read_byte(data + i++);
 302:mpu6050.c     ****             length = pgm_read_byte(data + i++);
 303:mpu6050.c     ****         } else {
 304:mpu6050.c     ****             bank = data[i++];
 305:mpu6050.c     ****             offset = data[i++];
 306:mpu6050.c     ****             length = data[i++];
 307:mpu6050.c     ****         }
 308:mpu6050.c     **** 
 309:mpu6050.c     ****         // write data or perform special action
 310:mpu6050.c     ****         if (length > 0) {
 311:mpu6050.c     ****             // regular block of data to write
 312:mpu6050.c     ****             if (useProgMem) {
 313:mpu6050.c     ****                 if (sizeof(progBuffer) < length) progBuffer = (uint8_t *)realloc(progBuffer, length
 314:mpu6050.c     ****                 for (j = 0; j < length; j++) progBuffer[j] = pgm_read_byte(data + i + j);
 315:mpu6050.c     ****             } else {
 316:mpu6050.c     ****                 progBuffer = (uint8_t *)data + i;
 317:mpu6050.c     ****             }
 318:mpu6050.c     ****             success = mpu6050_writeMemoryBlock(progBuffer, length, bank, offset, 1, 0);
 319:mpu6050.c     ****             i += length;
 320:mpu6050.c     ****         } else {
 321:mpu6050.c     ****             // special instruction
 322:mpu6050.c     ****             // NOTE: this kind of behavior (what and when to do certain things)
 323:mpu6050.c     ****             // is totally undocumented. This code is in here based on observed
 324:mpu6050.c     ****             // behavior only, and exactly why (or even whether) it has to be here
 325:mpu6050.c     ****             // is anybody's guess for now.
 326:mpu6050.c     ****             if (useProgMem) {
 327:mpu6050.c     ****                 special = pgm_read_byte(data + i++);
 328:mpu6050.c     ****             } else {
 329:mpu6050.c     ****                 special = data[i++];
 330:mpu6050.c     ****             }
 331:mpu6050.c     ****             if (special == 0x01) {
 332:mpu6050.c     ****                 // enable DMP-related interrupts
 333:mpu6050.c     **** 
 334:mpu6050.c     ****             	//mpu6050_writeBit(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_ZMOT_BIT, 1); //setIntZero
 335:mpu6050.c     ****             	//mpu6050_writeBit(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_FIFO_OFLOW_BIT, 1); //setI
 336:mpu6050.c     ****             	//mpu6050_writeBit(MPU6050_RA_INT_ENABLE, MPU6050_INTERRUPT_DMP_INT_BIT, 1); //setIntD
 337:mpu6050.c     ****             	mpu6050_writeByte(MPU6050_RA_INT_ENABLE, 0x32);  // single operation
 338:mpu6050.c     **** 
 339:mpu6050.c     ****                 success = 1;
 340:mpu6050.c     ****             } else {
 341:mpu6050.c     ****                 // unknown special command
 342:mpu6050.c     ****                 success = 0;
 343:mpu6050.c     ****             }
 344:mpu6050.c     ****         }
 345:mpu6050.c     **** 
 346:mpu6050.c     ****         if (!success) {
 347:mpu6050.c     ****             if (useProgMem) free(progBuffer);
 348:mpu6050.c     ****             return 0; // uh oh
 349:mpu6050.c     ****         }
 350:mpu6050.c     ****     }
 351:mpu6050.c     ****     if (useProgMem) free(progBuffer);
 352:mpu6050.c     ****     return 1;
 353:mpu6050.c     **** }
 354:mpu6050.c     **** 
 355:mpu6050.c     **** /*
 356:mpu6050.c     ****  * get the fifo count
 357:mpu6050.c     ****  */
 358:mpu6050.c     **** uint16_t mpu6050_getFIFOCount() {
 359:mpu6050.c     **** 	mpu6050_readBytes(MPU6050_RA_FIFO_COUNTH, 2, (uint8_t *)buffer);
 360:mpu6050.c     ****     return (((uint16_t)buffer[0]) << 8) | buffer[1];
 361:mpu6050.c     **** }
 362:mpu6050.c     **** 
 363:mpu6050.c     **** /*
 364:mpu6050.c     ****  * read fifo bytes
 365:mpu6050.c     ****  */
 366:mpu6050.c     **** void mpu6050_getFIFOBytes(uint8_t *data, uint8_t length) {
 367:mpu6050.c     **** 	mpu6050_readBytes(MPU6050_RA_FIFO_R_W, length, data);
 368:mpu6050.c     **** }
 369:mpu6050.c     **** 
 370:mpu6050.c     **** /*
 371:mpu6050.c     ****  * get the interrupt status
 372:mpu6050.c     ****  */
 373:mpu6050.c     **** uint8_t mpu6050_getIntStatus() {
 374:mpu6050.c     **** 	mpu6050_readByte(MPU6050_RA_INT_STATUS, (uint8_t *)buffer);
 375:mpu6050.c     ****     return buffer[0];
 376:mpu6050.c     **** }
 377:mpu6050.c     **** 
 378:mpu6050.c     **** /*
 379:mpu6050.c     ****  * reset fifo
 380:mpu6050.c     ****  */
 381:mpu6050.c     **** void mpu6050_resetFIFO() {
 382:mpu6050.c     **** 	mpu6050_writeBit(MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1);
 383:mpu6050.c     **** }
 384:mpu6050.c     **** 
 385:mpu6050.c     **** /*
 386:mpu6050.c     ****  * get gyro offset X
 387:mpu6050.c     ****  */
 388:mpu6050.c     **** int8_t mpu6050_getXGyroOffset() {
 389:mpu6050.c     **** 	mpu6050_readBits(MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, (uint8_t 
 390:mpu6050.c     ****     return buffer[0];
 391:mpu6050.c     **** }
 392:mpu6050.c     **** 
 393:mpu6050.c     **** /*
 394:mpu6050.c     ****  * set gyro offset X
 395:mpu6050.c     ****  */
 396:mpu6050.c     **** void mpu6050_setXGyroOffset(int8_t offset) {
 397:mpu6050.c     **** 	mpu6050_writeBits(MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
 398:mpu6050.c     **** }
 399:mpu6050.c     **** 
 400:mpu6050.c     **** /*
 401:mpu6050.c     ****  * get gyro offset Y
 402:mpu6050.c     ****  */
 403:mpu6050.c     **** int8_t mpu6050_getYGyroOffset() {
 404:mpu6050.c     **** 	mpu6050_readBits(MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, (uint8_t 
 405:mpu6050.c     ****     return buffer[0];
 406:mpu6050.c     **** }
 407:mpu6050.c     **** 
 408:mpu6050.c     **** /*
 409:mpu6050.c     ****  * set gyro offset Y
 410:mpu6050.c     ****  */
 411:mpu6050.c     **** void mpu6050_setYGyroOffset(int8_t offset) {
 412:mpu6050.c     **** 	mpu6050_writeBits(MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
 413:mpu6050.c     **** }
 414:mpu6050.c     **** 
 415:mpu6050.c     **** /*
 416:mpu6050.c     ****  * get gyro offset Z
 417:mpu6050.c     ****  */
 418:mpu6050.c     **** int8_t mpu6050_getZGyroOffset() {
 419:mpu6050.c     **** 	mpu6050_readBits(MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, (uint8_t 
 420:mpu6050.c     ****     return buffer[0];
 421:mpu6050.c     **** }
 422:mpu6050.c     **** 
 423:mpu6050.c     **** /*
 424:mpu6050.c     ****  * set gyro offset Z
 425:mpu6050.c     ****  */
 426:mpu6050.c     **** void mpu6050_setZGyroOffset(int8_t offset) {
 427:mpu6050.c     **** 	mpu6050_writeBits(MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
 428:mpu6050.c     **** }
 429:mpu6050.c     **** #endif
 430:mpu6050.c     **** 
 431:mpu6050.c     **** /*
 432:mpu6050.c     ****  * set sleep disabled
 433:mpu6050.c     ****  */
 434:mpu6050.c     **** void mpu6050_setSleepDisabled() {
 1686               		.loc 3 434 0
 1687               		.cfi_startproc
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 0 */
 1691               	.L__stack_usage = 0
 435:mpu6050.c     **** 	mpu6050_writeBit(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 0);
 1692               		.loc 3 435 0
 1693 06a0 40E0      		ldi r20,0
 1694 06a2 66E0      		ldi r22,lo8(6)
 1695 06a4 8BE6      		ldi r24,lo8(107)
 1696 06a6 0C94 0000 		jmp mpu6050_writeBit
 1697               	.LVL146:
 1698               		.cfi_endproc
 1699               	.LFE30:
 1701               	.global	mpu6050_setSleepEnabled
 1703               	mpu6050_setSleepEnabled:
 1704               	.LFB31:
 436:mpu6050.c     **** }
 437:mpu6050.c     **** 
 438:mpu6050.c     **** /*
 439:mpu6050.c     ****  * set sleep enabled
 440:mpu6050.c     ****  */
 441:mpu6050.c     **** void mpu6050_setSleepEnabled() {
 1705               		.loc 3 441 0
 1706               		.cfi_startproc
 1707               	/* prologue: function */
 1708               	/* frame size = 0 */
 1709               	/* stack size = 0 */
 1710               	.L__stack_usage = 0
 442:mpu6050.c     **** 	mpu6050_writeBit(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1);
 1711               		.loc 3 442 0
 1712 06aa 41E0      		ldi r20,lo8(1)
 1713 06ac 66E0      		ldi r22,lo8(6)
 1714 06ae 8BE6      		ldi r24,lo8(107)
 1715 06b0 0C94 0000 		jmp mpu6050_writeBit
 1716               	.LVL147:
 1717               		.cfi_endproc
 1718               	.LFE31:
 1720               	.global	mpu6050_testConnection
 1722               	mpu6050_testConnection:
 1723               	.LFB32:
 443:mpu6050.c     **** }
 444:mpu6050.c     **** 
 445:mpu6050.c     **** 
 446:mpu6050.c     **** /*
 447:mpu6050.c     ****  * test connectino to chip
 448:mpu6050.c     ****  */
 449:mpu6050.c     **** uint8_t mpu6050_testConnection() {
 1724               		.loc 3 449 0
 1725               		.cfi_startproc
 1726               	/* prologue: function */
 1727               	/* frame size = 0 */
 1728               	/* stack size = 0 */
 1729               	.L__stack_usage = 0
 450:mpu6050.c     ****     int16_t* ax;
 451:mpu6050.c     **** 
 452:mpu6050.c     **** 	//mpu6050_readBits(MPU6050_RA_WHO_AM_I, MPU6050_WHO_AM_I_BIT, MPU6050_WHO_AM_I_LENGTH, (uint8_t *)
 453:mpu6050.c     ****     //mpu6050_readBytes(MPU6050_RA_ACCEL_XOUT_H, 14, (uint8_t *)buffer);
 454:mpu6050.c     **** 
 455:mpu6050.c     ****     //*ax = (((int16_t)buffer[0]) << 8) | buffer[1];
 456:mpu6050.c     ****     //return &ax;
 457:mpu6050.c     ****     return buffer[1];
 1730               		.loc 3 457 0
 1731 06b4 8091 0000 		lds r24,buffer+1
 458:mpu6050.c     **** }
 1732               		.loc 3 458 0
 1733 06b8 0895      		ret
 1734               		.cfi_endproc
 1735               	.LFE32:
 1737               	.global	mpu6050_init
 1739               	mpu6050_init:
 1740               	.LFB33:
 459:mpu6050.c     **** 
 460:mpu6050.c     **** /*
 461:mpu6050.c     ****  * initialize the accel and gyro
 462:mpu6050.c     ****  */
 463:mpu6050.c     **** void mpu6050_init() {
 1741               		.loc 3 463 0
 1742               		.cfi_startproc
 1743               	/* prologue: function */
 1744               	/* frame size = 0 */
 1745               	/* stack size = 0 */
 1746               	.L__stack_usage = 0
 464:mpu6050.c     **** 
 465:mpu6050.c     **** 	#if MPU6050_I2CINIT == 1
 466:mpu6050.c     **** 	//init i2c
 467:mpu6050.c     **** 
 468:mpu6050.c     **** 	i2c_init();
 1747               		.loc 3 468 0
 1748 06ba 0E94 0000 		call i2c_init
 1749               	.LVL148:
 1750               	.LBB50:
 1751               	.LBB51:
 1752               		.loc 4 246 0
 1753 06be 8AE1      		ldi r24,lo8(26)
 1754 06c0 8A95      		1: dec r24
 1755 06c2 01F4      		brne 1b
 1756 06c4 00C0      		rjmp .
 1757               	.LVL149:
 1758               	.LBE51:
 1759               	.LBE50:
 1760               	.LBB52:
 1761               	.LBB53:
 1762 06c6 21E0      		ldi r18,lo8(1)
 1763 06c8 43E0      		ldi r20,lo8(3)
 1764 06ca 62E0      		ldi r22,lo8(2)
 1765 06cc 8BE6      		ldi r24,lo8(107)
 1766 06ce 0E94 0000 		call mpu6050_writeBits.part.2
 1767               	.LVL150:
 1768               	.LBE53:
 1769               	.LBE52:
 1770               	.LBB54:
 1771               	.LBB55:
 1772 06d2 23E0      		ldi r18,lo8(3)
 1773 06d4 43E0      		ldi r20,lo8(3)
 1774 06d6 62E0      		ldi r22,lo8(2)
 1775 06d8 8AE1      		ldi r24,lo8(26)
 1776 06da 0E94 0000 		call mpu6050_writeBits.part.2
 1777               	.LVL151:
 1778               	.LBE55:
 1779               	.LBE54:
 469:mpu6050.c     **** 
 470:mpu6050.c     **** 	_delay_us(10);
 471:mpu6050.c     **** 	#endif
 472:mpu6050.c     **** 
 473:mpu6050.c     **** 	//set clock source
 474:mpu6050.c     **** 	//  it is highly recommended that the device be configured to use one of the gyroscopes (or an ext
 475:mpu6050.c     **** 	//  as the clock reference for improved stability
 476:mpu6050.c     **** 	mpu6050_writeBits(MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, MPU6
 477:mpu6050.c     **** 	//set DLPF bandwidth to 42Hz
 478:mpu6050.c     **** 	mpu6050_writeBits(MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, MPU605
 479:mpu6050.c     ****     //set sampe rate
 480:mpu6050.c     **** 	mpu6050_writeByte(MPU6050_RA_SMPLRT_DIV, 1); //1khz / (1 + 4) = 200Hz
 1780               		.loc 3 480 0
 1781 06de 61E0      		ldi r22,lo8(1)
 1782 06e0 89E1      		ldi r24,lo8(25)
 1783 06e2 0E94 0000 		call mpu6050_writeByte
 1784               	.LVL152:
 1785               	.LBB56:
 1786               	.LBB57:
 1787 06e6 23E0      		ldi r18,lo8(3)
 1788 06e8 42E0      		ldi r20,lo8(2)
 1789 06ea 64E0      		ldi r22,lo8(4)
 1790 06ec 8BE1      		ldi r24,lo8(27)
 1791 06ee 0E94 0000 		call mpu6050_writeBits.part.2
 1792               	.LVL153:
 1793               	.LBE57:
 1794               	.LBE56:
 1795               	.LBB58:
 1796               	.LBB59:
 1797 06f2 23E0      		ldi r18,lo8(3)
 1798 06f4 42E0      		ldi r20,lo8(2)
 1799 06f6 64E0      		ldi r22,lo8(4)
 1800 06f8 8CE1      		ldi r24,lo8(28)
 1801 06fa 0E94 0000 		call mpu6050_writeBits.part.2
 1802               	.LVL154:
 1803               	.LBE59:
 1804               	.LBE58:
 481:mpu6050.c     **** 	//set gyro range
 482:mpu6050.c     **** 	mpu6050_writeBits(MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGT
 483:mpu6050.c     **** 	//set accel range
 484:mpu6050.c     **** 	mpu6050_writeBits(MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LE
 485:mpu6050.c     **** 	//set sleep disabled
 486:mpu6050.c     **** 	mpu6050_setSleepDisabled();
 1805               		.loc 3 486 0
 1806 06fe 0C94 0000 		jmp mpu6050_setSleepDisabled
 1807               	.LVL155:
 1808               		.cfi_endproc
 1809               	.LFE33:
 1811               	.global	mpu6050_getRawData
 1813               	mpu6050_getRawData:
 1814               	.LFB34:
 487:mpu6050.c     **** 
 488:mpu6050.c     **** 	#if MPU6050_GETATTITUDE == 1
 489:mpu6050.c     **** 	MPU6050_TIMER0INIT
 490:mpu6050.c     **** 	#endif
 491:mpu6050.c     **** }
 492:mpu6050.c     **** 
 493:mpu6050.c     **** //can not accept many request if we alreay have getattitude requests
 494:mpu6050.c     **** /*
 495:mpu6050.c     ****  * get raw data
 496:mpu6050.c     ****  */
 497:mpu6050.c     **** void mpu6050_getRawData(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* g
 1815               		.loc 3 497 0
 1816               		.cfi_startproc
 1817               	.LVL156:
 1818 0702 8F92      		push r8
 1819               	.LCFI69:
 1820               		.cfi_def_cfa_offset 3
 1821               		.cfi_offset 8, -2
 1822 0704 9F92      		push r9
 1823               	.LCFI70:
 1824               		.cfi_def_cfa_offset 4
 1825               		.cfi_offset 9, -3
 1826 0706 AF92      		push r10
 1827               	.LCFI71:
 1828               		.cfi_def_cfa_offset 5
 1829               		.cfi_offset 10, -4
 1830 0708 BF92      		push r11
 1831               	.LCFI72:
 1832               		.cfi_def_cfa_offset 6
 1833               		.cfi_offset 11, -5
 1834 070a CF92      		push r12
 1835               	.LCFI73:
 1836               		.cfi_def_cfa_offset 7
 1837               		.cfi_offset 12, -6
 1838 070c DF92      		push r13
 1839               	.LCFI74:
 1840               		.cfi_def_cfa_offset 8
 1841               		.cfi_offset 13, -7
 1842 070e EF92      		push r14
 1843               	.LCFI75:
 1844               		.cfi_def_cfa_offset 9
 1845               		.cfi_offset 14, -8
 1846 0710 FF92      		push r15
 1847               	.LCFI76:
 1848               		.cfi_def_cfa_offset 10
 1849               		.cfi_offset 15, -9
 1850 0712 0F93      		push r16
 1851               	.LCFI77:
 1852               		.cfi_def_cfa_offset 11
 1853               		.cfi_offset 16, -10
 1854 0714 1F93      		push r17
 1855               	.LCFI78:
 1856               		.cfi_def_cfa_offset 12
 1857               		.cfi_offset 17, -11
 1858 0716 CF93      		push r28
 1859               	.LCFI79:
 1860               		.cfi_def_cfa_offset 13
 1861               		.cfi_offset 28, -12
 1862 0718 DF93      		push r29
 1863               	.LCFI80:
 1864               		.cfi_def_cfa_offset 14
 1865               		.cfi_offset 29, -13
 1866               	/* prologue: function */
 1867               	/* frame size = 0 */
 1868               	/* stack size = 12 */
 1869               	.L__stack_usage = 12
 1870 071a EC01      		movw r28,r24
 1871 071c 5B01      		movw r10,r22
 1872 071e 6A01      		movw r12,r20
 1873 0720 4901      		movw r8,r18
 498:mpu6050.c     **** 	mpu6050_readBytes(MPU6050_RA_ACCEL_XOUT_H, 14, (uint8_t *)buffer);
 1874               		.loc 3 498 0
 1875 0722 40E0      		ldi r20,lo8(buffer)
 1876 0724 50E0      		ldi r21,hi8(buffer)
 1877               	.LVL157:
 1878 0726 6EE0      		ldi r22,lo8(14)
 1879               	.LVL158:
 1880 0728 8BE3      		ldi r24,lo8(59)
 1881               	.LVL159:
 1882 072a 0E94 0000 		call mpu6050_readBytes
 1883               	.LVL160:
 499:mpu6050.c     **** 
 500:mpu6050.c     ****     *ax = (((int16_t)buffer[0]) << 8) | buffer[1];
 1884               		.loc 3 500 0
 1885 072e 2091 0000 		lds r18,buffer
 1886 0732 8091 0000 		lds r24,buffer+1
 1887 0736 90E0      		ldi r25,0
 1888 0738 922B      		or r25,r18
 1889 073a 9983      		std Y+1,r25
 1890 073c 8883      		st Y,r24
 501:mpu6050.c     ****     *ay = (((int16_t)buffer[2]) << 8) | buffer[3];
 1891               		.loc 3 501 0
 1892 073e 2091 0000 		lds r18,buffer+2
 1893 0742 8091 0000 		lds r24,buffer+3
 1894 0746 90E0      		ldi r25,0
 1895 0748 922B      		or r25,r18
 1896 074a F501      		movw r30,r10
 1897 074c 9183      		std Z+1,r25
 1898 074e 8083      		st Z,r24
 502:mpu6050.c     ****     *az = (((int16_t)buffer[4]) << 8) | buffer[5];
 1899               		.loc 3 502 0
 1900 0750 2091 0000 		lds r18,buffer+4
 1901 0754 8091 0000 		lds r24,buffer+5
 1902 0758 90E0      		ldi r25,0
 1903 075a 922B      		or r25,r18
 1904 075c F601      		movw r30,r12
 1905 075e 9183      		std Z+1,r25
 1906 0760 8083      		st Z,r24
 503:mpu6050.c     ****     *gx = (((int16_t)buffer[8]) << 8) | buffer[9];
 1907               		.loc 3 503 0
 1908 0762 2091 0000 		lds r18,buffer+8
 1909 0766 8091 0000 		lds r24,buffer+9
 1910 076a 90E0      		ldi r25,0
 1911 076c 922B      		or r25,r18
 1912 076e F401      		movw r30,r8
 1913 0770 9183      		std Z+1,r25
 1914 0772 8083      		st Z,r24
 504:mpu6050.c     ****     *gy = (((int16_t)buffer[10]) << 8) | buffer[11];
 1915               		.loc 3 504 0
 1916 0774 2091 0000 		lds r18,buffer+10
 1917 0778 8091 0000 		lds r24,buffer+11
 1918 077c 90E0      		ldi r25,0
 1919 077e 922B      		or r25,r18
 1920 0780 F801      		movw r30,r16
 1921 0782 9183      		std Z+1,r25
 1922 0784 8083      		st Z,r24
 505:mpu6050.c     ****     *gz = (((int16_t)buffer[12]) << 8) | buffer[13];
 1923               		.loc 3 505 0
 1924 0786 2091 0000 		lds r18,buffer+12
 1925 078a 8091 0000 		lds r24,buffer+13
 1926 078e 90E0      		ldi r25,0
 1927 0790 922B      		or r25,r18
 1928 0792 F701      		movw r30,r14
 1929 0794 9183      		std Z+1,r25
 1930 0796 8083      		st Z,r24
 1931               	/* epilogue start */
 506:mpu6050.c     **** }
 1932               		.loc 3 506 0
 1933 0798 DF91      		pop r29
 1934 079a CF91      		pop r28
 1935               	.LVL161:
 1936 079c 1F91      		pop r17
 1937 079e 0F91      		pop r16
 1938               	.LVL162:
 1939 07a0 FF90      		pop r15
 1940 07a2 EF90      		pop r14
 1941               	.LVL163:
 1942 07a4 DF90      		pop r13
 1943 07a6 CF90      		pop r12
 1944               	.LVL164:
 1945 07a8 BF90      		pop r11
 1946 07aa AF90      		pop r10
 1947               	.LVL165:
 1948 07ac 9F90      		pop r9
 1949 07ae 8F90      		pop r8
 1950               	.LVL166:
 1951 07b0 0895      		ret
 1952               		.cfi_endproc
 1953               	.LFE34:
 1955               	.global	__floatsisf
 1956               	.global	__mulsf3
 1957               	.global	__divsf3
 1958               	.global	mpu6050_getConvData
 1960               	mpu6050_getConvData:
 1961               	.LFB35:
 507:mpu6050.c     **** 
 508:mpu6050.c     **** /*
 509:mpu6050.c     ****  * get raw data converted to g and deg/sec values
 510:mpu6050.c     ****  */
 511:mpu6050.c     **** void mpu6050_getConvData(double* axg, double* ayg, double* azg, double* gxds, double* gyds, double*
 1962               		.loc 3 511 0
 1963               		.cfi_startproc
 1964               	.LVL167:
 1965 07b2 2F92      		push r2
 1966               	.LCFI81:
 1967               		.cfi_def_cfa_offset 3
 1968               		.cfi_offset 2, -2
 1969 07b4 3F92      		push r3
 1970               	.LCFI82:
 1971               		.cfi_def_cfa_offset 4
 1972               		.cfi_offset 3, -3
 1973 07b6 4F92      		push r4
 1974               	.LCFI83:
 1975               		.cfi_def_cfa_offset 5
 1976               		.cfi_offset 4, -4
 1977 07b8 5F92      		push r5
 1978               	.LCFI84:
 1979               		.cfi_def_cfa_offset 6
 1980               		.cfi_offset 5, -5
 1981 07ba 6F92      		push r6
 1982               	.LCFI85:
 1983               		.cfi_def_cfa_offset 7
 1984               		.cfi_offset 6, -6
 1985 07bc 7F92      		push r7
 1986               	.LCFI86:
 1987               		.cfi_def_cfa_offset 8
 1988               		.cfi_offset 7, -7
 1989 07be 8F92      		push r8
 1990               	.LCFI87:
 1991               		.cfi_def_cfa_offset 9
 1992               		.cfi_offset 8, -8
 1993 07c0 9F92      		push r9
 1994               	.LCFI88:
 1995               		.cfi_def_cfa_offset 10
 1996               		.cfi_offset 9, -9
 1997 07c2 AF92      		push r10
 1998               	.LCFI89:
 1999               		.cfi_def_cfa_offset 11
 2000               		.cfi_offset 10, -10
 2001 07c4 BF92      		push r11
 2002               	.LCFI90:
 2003               		.cfi_def_cfa_offset 12
 2004               		.cfi_offset 11, -11
 2005 07c6 CF92      		push r12
 2006               	.LCFI91:
 2007               		.cfi_def_cfa_offset 13
 2008               		.cfi_offset 12, -12
 2009 07c8 DF92      		push r13
 2010               	.LCFI92:
 2011               		.cfi_def_cfa_offset 14
 2012               		.cfi_offset 13, -13
 2013 07ca EF92      		push r14
 2014               	.LCFI93:
 2015               		.cfi_def_cfa_offset 15
 2016               		.cfi_offset 14, -14
 2017 07cc FF92      		push r15
 2018               	.LCFI94:
 2019               		.cfi_def_cfa_offset 16
 2020               		.cfi_offset 15, -15
 2021 07ce 0F93      		push r16
 2022               	.LCFI95:
 2023               		.cfi_def_cfa_offset 17
 2024               		.cfi_offset 16, -16
 2025 07d0 1F93      		push r17
 2026               	.LCFI96:
 2027               		.cfi_def_cfa_offset 18
 2028               		.cfi_offset 17, -17
 2029 07d2 CF93      		push r28
 2030               	.LCFI97:
 2031               		.cfi_def_cfa_offset 19
 2032               		.cfi_offset 28, -18
 2033 07d4 DF93      		push r29
 2034               	.LCFI98:
 2035               		.cfi_def_cfa_offset 20
 2036               		.cfi_offset 29, -19
 2037 07d6 CDB7      		in r28,__SP_L__
 2038 07d8 DEB7      		in r29,__SP_H__
 2039               	.LCFI99:
 2040               		.cfi_def_cfa_register 28
 2041 07da 2C97      		sbiw r28,12
 2042               	.LCFI100:
 2043               		.cfi_def_cfa_offset 32
 2044 07dc 0FB6      		in __tmp_reg__,__SREG__
 2045 07de F894      		cli
 2046 07e0 DEBF      		out __SP_H__,r29
 2047 07e2 0FBE      		out __SREG__,__tmp_reg__
 2048 07e4 CDBF      		out __SP_L__,r28
 2049               	/* prologue: function */
 2050               	/* frame size = 12 */
 2051               	/* stack size = 30 */
 2052               	.L__stack_usage = 30
 2053 07e6 3C01      		movw r6,r24
 2054 07e8 4B01      		movw r8,r22
 2055 07ea 5A01      		movw r10,r20
 2056 07ec 6901      		movw r12,r18
 2057 07ee 2801      		movw r4,r16
 2058 07f0 1701      		movw r2,r14
 512:mpu6050.c     **** 	int16_t ax = 0;
 2059               		.loc 3 512 0
 2060 07f2 1C86      		std Y+12,__zero_reg__
 2061 07f4 1B86      		std Y+11,__zero_reg__
 513:mpu6050.c     **** 	int16_t ay = 0;
 2062               		.loc 3 513 0
 2063 07f6 1A86      		std Y+10,__zero_reg__
 2064 07f8 1986      		std Y+9,__zero_reg__
 514:mpu6050.c     **** 	int16_t az = 0;
 2065               		.loc 3 514 0
 2066 07fa 1886      		std Y+8,__zero_reg__
 2067 07fc 1F82      		std Y+7,__zero_reg__
 515:mpu6050.c     **** 	int16_t gx = 0;
 2068               		.loc 3 515 0
 2069 07fe 1E82      		std Y+6,__zero_reg__
 2070 0800 1D82      		std Y+5,__zero_reg__
 516:mpu6050.c     **** 	int16_t gy = 0;
 2071               		.loc 3 516 0
 2072 0802 1C82      		std Y+4,__zero_reg__
 2073 0804 1B82      		std Y+3,__zero_reg__
 517:mpu6050.c     **** 	int16_t gz = 0;
 2074               		.loc 3 517 0
 2075 0806 1A82      		std Y+2,__zero_reg__
 2076 0808 1982      		std Y+1,__zero_reg__
 518:mpu6050.c     **** 	mpu6050_getRawData(&ax, &ay, &az, &gx, &gy, &gz);
 2077               		.loc 3 518 0
 2078 080a CE01      		movw r24,r28
 2079               	.LVL168:
 2080 080c 0196      		adiw r24,1
 2081 080e 7C01      		movw r14,r24
 2082               	.LVL169:
 2083 0810 8E01      		movw r16,r28
 2084               	.LVL170:
 2085 0812 0D5F      		subi r16,-3
 2086 0814 1F4F      		sbci r17,-1
 2087 0816 9E01      		movw r18,r28
 2088               	.LVL171:
 2089 0818 2B5F      		subi r18,-5
 2090 081a 3F4F      		sbci r19,-1
 2091 081c AE01      		movw r20,r28
 2092               	.LVL172:
 2093 081e 495F      		subi r20,-7
 2094 0820 5F4F      		sbci r21,-1
 2095 0822 BE01      		movw r22,r28
 2096               	.LVL173:
 2097 0824 675F      		subi r22,-9
 2098 0826 7F4F      		sbci r23,-1
 2099 0828 CE01      		movw r24,r28
 2100 082a 0B96      		adiw r24,11
 2101 082c 0E94 0000 		call mpu6050_getRawData
 2102               	.LVL174:
 519:mpu6050.c     **** 
 520:mpu6050.c     **** 	#if MPU6050_CALIBRATEDACCGYRO == 1
 521:mpu6050.c     ****     *axg = (double)(ax-MPU6050_AXOFFSET)/MPU6050_AXGAIN;
 2103               		.loc 3 521 0
 2104 0830 6B85      		ldd r22,Y+11
 2105 0832 7C85      		ldd r23,Y+12
 2106 0834 8827      		clr r24
 2107 0836 77FD      		sbrc r23,7
 2108 0838 8095      		com r24
 2109 083a 982F      		mov r25,r24
 2110 083c 0E94 0000 		call __floatsisf
 2111               	.LVL175:
 2112 0840 20E0      		ldi r18,0
 2113 0842 30E0      		ldi r19,0
 2114 0844 40E8      		ldi r20,lo8(-128)
 2115 0846 58E3      		ldi r21,lo8(56)
 2116 0848 0E94 0000 		call __mulsf3
 2117               	.LVL176:
 2118 084c F301      		movw r30,r6
 2119 084e 6083      		st Z,r22
 2120 0850 7183      		std Z+1,r23
 2121 0852 8283      		std Z+2,r24
 2122 0854 9383      		std Z+3,r25
 522:mpu6050.c     ****     *ayg = (double)(ay-MPU6050_AYOFFSET)/MPU6050_AYGAIN;
 2123               		.loc 3 522 0
 2124 0856 6985      		ldd r22,Y+9
 2125 0858 7A85      		ldd r23,Y+10
 2126 085a 8827      		clr r24
 2127 085c 77FD      		sbrc r23,7
 2128 085e 8095      		com r24
 2129 0860 982F      		mov r25,r24
 2130 0862 0E94 0000 		call __floatsisf
 2131               	.LVL177:
 2132 0866 20E0      		ldi r18,0
 2133 0868 30E0      		ldi r19,0
 2134 086a 40E8      		ldi r20,lo8(-128)
 2135 086c 58E3      		ldi r21,lo8(56)
 2136 086e 0E94 0000 		call __mulsf3
 2137               	.LVL178:
 2138 0872 F401      		movw r30,r8
 2139 0874 6083      		st Z,r22
 2140 0876 7183      		std Z+1,r23
 2141 0878 8283      		std Z+2,r24
 2142 087a 9383      		std Z+3,r25
 523:mpu6050.c     ****     *azg = (double)(az-MPU6050_AZOFFSET)/MPU6050_AZGAIN;
 2143               		.loc 3 523 0
 2144 087c 6F81      		ldd r22,Y+7
 2145 087e 7885      		ldd r23,Y+8
 2146 0880 8827      		clr r24
 2147 0882 77FD      		sbrc r23,7
 2148 0884 8095      		com r24
 2149 0886 982F      		mov r25,r24
 2150 0888 0E94 0000 		call __floatsisf
 2151               	.LVL179:
 2152 088c 20E0      		ldi r18,0
 2153 088e 30E0      		ldi r19,0
 2154 0890 40E8      		ldi r20,lo8(-128)
 2155 0892 58E3      		ldi r21,lo8(56)
 2156 0894 0E94 0000 		call __mulsf3
 2157               	.LVL180:
 2158 0898 F501      		movw r30,r10
 2159 089a 6083      		st Z,r22
 2160 089c 7183      		std Z+1,r23
 2161 089e 8283      		std Z+2,r24
 2162 08a0 9383      		std Z+3,r25
 524:mpu6050.c     ****     *gxds = (double)(gx-MPU6050_GXOFFSET)/MPU6050_GXGAIN;
 2163               		.loc 3 524 0
 2164 08a2 6D81      		ldd r22,Y+5
 2165 08a4 7E81      		ldd r23,Y+6
 2166 08a6 665D      		subi r22,-42
 2167 08a8 7F4F      		sbci r23,-1
 2168 08aa 8827      		clr r24
 2169 08ac 77FD      		sbrc r23,7
 2170 08ae 8095      		com r24
 2171 08b0 982F      		mov r25,r24
 2172 08b2 0E94 0000 		call __floatsisf
 2173               	.LVL181:
 2174 08b6 23E3      		ldi r18,lo8(51)
 2175 08b8 33E3      		ldi r19,lo8(51)
 2176 08ba 43E8      		ldi r20,lo8(-125)
 2177 08bc 51E4      		ldi r21,lo8(65)
 2178 08be 0E94 0000 		call __divsf3
 2179               	.LVL182:
 2180 08c2 F601      		movw r30,r12
 2181 08c4 6083      		st Z,r22
 2182 08c6 7183      		std Z+1,r23
 2183 08c8 8283      		std Z+2,r24
 2184 08ca 9383      		std Z+3,r25
 525:mpu6050.c     **** 	*gyds = (double)(gy-MPU6050_GYOFFSET)/MPU6050_GYGAIN;
 2185               		.loc 3 525 0
 2186 08cc 6B81      		ldd r22,Y+3
 2187 08ce 7C81      		ldd r23,Y+4
 2188 08d0 6950      		subi r22,9
 2189 08d2 7109      		sbc r23,__zero_reg__
 2190 08d4 8827      		clr r24
 2191 08d6 77FD      		sbrc r23,7
 2192 08d8 8095      		com r24
 2193 08da 982F      		mov r25,r24
 2194 08dc 0E94 0000 		call __floatsisf
 2195               	.LVL183:
 2196 08e0 23E3      		ldi r18,lo8(51)
 2197 08e2 33E3      		ldi r19,lo8(51)
 2198 08e4 43E8      		ldi r20,lo8(-125)
 2199 08e6 51E4      		ldi r21,lo8(65)
 2200 08e8 0E94 0000 		call __divsf3
 2201               	.LVL184:
 2202 08ec F201      		movw r30,r4
 2203 08ee 6083      		st Z,r22
 2204 08f0 7183      		std Z+1,r23
 2205 08f2 8283      		std Z+2,r24
 2206 08f4 9383      		std Z+3,r25
 526:mpu6050.c     **** 	*gzds = (double)(gz-MPU6050_GZOFFSET)/MPU6050_GZGAIN;
 2207               		.loc 3 526 0
 2208 08f6 6981      		ldd r22,Y+1
 2209 08f8 7A81      		ldd r23,Y+2
 2210 08fa 635E      		subi r22,-29
 2211 08fc 7F4F      		sbci r23,-1
 2212 08fe 8827      		clr r24
 2213 0900 77FD      		sbrc r23,7
 2214 0902 8095      		com r24
 2215 0904 982F      		mov r25,r24
 2216 0906 0E94 0000 		call __floatsisf
 2217               	.LVL185:
 2218 090a 23E3      		ldi r18,lo8(51)
 2219 090c 33E3      		ldi r19,lo8(51)
 2220 090e 43E8      		ldi r20,lo8(-125)
 2221 0910 51E4      		ldi r21,lo8(65)
 2222 0912 0E94 0000 		call __divsf3
 2223               	.LVL186:
 2224 0916 F101      		movw r30,r2
 2225 0918 6083      		st Z,r22
 2226 091a 7183      		std Z+1,r23
 2227 091c 8283      		std Z+2,r24
 2228 091e 9383      		std Z+3,r25
 2229               	/* epilogue start */
 527:mpu6050.c     **** 	#else
 528:mpu6050.c     ****     *axg = (double)(ax)/MPU6050_AGAIN;
 529:mpu6050.c     ****     *ayg = (double)(ay)/MPU6050_AGAIN;
 530:mpu6050.c     ****     *azg = (double)(az)/MPU6050_AGAIN;
 531:mpu6050.c     ****     *gxds = (double)(gx)/MPU6050_GGAIN;
 532:mpu6050.c     **** 	*gyds = (double)(gy)/MPU6050_GGAIN;
 533:mpu6050.c     **** 	*gzds = (double)(gz)/MPU6050_GGAIN;
 534:mpu6050.c     **** 	#endif
 535:mpu6050.c     **** }
 2230               		.loc 3 535 0
 2231 0920 2C96      		adiw r28,12
 2232 0922 0FB6      		in __tmp_reg__,__SREG__
 2233 0924 F894      		cli
 2234 0926 DEBF      		out __SP_H__,r29
 2235 0928 0FBE      		out __SREG__,__tmp_reg__
 2236 092a CDBF      		out __SP_L__,r28
 2237 092c DF91      		pop r29
 2238 092e CF91      		pop r28
 2239 0930 1F91      		pop r17
 2240 0932 0F91      		pop r16
 2241 0934 FF90      		pop r15
 2242 0936 EF90      		pop r14
 2243 0938 DF90      		pop r13
 2244 093a CF90      		pop r12
 2245               	.LVL187:
 2246 093c BF90      		pop r11
 2247 093e AF90      		pop r10
 2248               	.LVL188:
 2249 0940 9F90      		pop r9
 2250 0942 8F90      		pop r8
 2251               	.LVL189:
 2252 0944 7F90      		pop r7
 2253 0946 6F90      		pop r6
 2254               	.LVL190:
 2255 0948 5F90      		pop r5
 2256 094a 4F90      		pop r4
 2257               	.LVL191:
 2258 094c 3F90      		pop r3
 2259 094e 2F90      		pop r2
 2260               	.LVL192:
 2261 0950 0895      		ret
 2262               		.cfi_endproc
 2263               	.LFE35:
 2265               	.global	GetRawDataTest
 2267               	GetRawDataTest:
 2268               	.LFB37:
 2269               		.file 5 "main.c"
   1:main.c        **** /* Created 05/22/2012 by Jordan McConnell at Sparkfun Electronics
   2:main.c        ****  * This code is beerware, you know what I'm sayin'?
   3:main.c        ****  *
   4:main.c        ****  * Built on WinXP SP3 and WinAVR-20100110, AVRDUDE 5.10
   5:main.c        ****  *
   6:main.c        ****  * This code is a simple example of digital input for Sparkfun's
   7:main.c        ****  * 32U4 Breakout Board using C and standard AVR libraries.  It
   8:main.c        ****  * teaches you how to read the status of a digital pin to determine
   9:main.c        ****  * whether its current status is HIGH or LOW.
  10:main.c        ****  *
  11:main.c        ****  * Pin PF0 is used as a digital input.  If its status is HIGH,
  12:main.c        ****  * pin PD5 toggles each second, if it's status is LOW, pin PD6
  13:main.c        ****  * toggles each second instead.
  14:main.c        ****  *
  15:main.c        ****  * The user can connect LED's to pins PD5 and PD6 or use a multimeter
  16:main.c        ****  * to verify operation.  If pin PF0 is left unconnected, it's status
  17:main.c        ****  * will be HIGH due to internal pullup resistors, and PD5 toggles.
  18:main.c        ****  * If PF0 is connected to ground, PD6 toggles each second instead.
  19:main.c        ****  */
  20:main.c        **** 
  21:main.c        **** // Libraries for register names and the delay function
  22:main.c        **** 
  23:main.c        **** 
  24:main.c        **** 
  25:main.c        **** #include <stdlib.h>
  26:main.c        **** #include <avr/interrupt.h>
  27:main.c        **** #include <avr/pgmspace.h>   
  28:main.c        **** #include <avr/io.h>
  29:main.c        **** #include <stdio.h>
  30:main.c        **** #include <util/delay.h>
  31:main.c        **** #include <math.h>  //include libm
  32:main.c        **** 
  33:main.c        **** #include "trtSettings.h"
  34:main.c        **** #include "trtUart.h"
  35:main.c        **** #include "trtUart.c"
  36:main.c        **** 
  37:main.c        **** #include "mpu6050.c"
  38:main.c        **** #include "mpu6050.h"
  39:main.c        **** // UART file descriptor
  40:main.c        **** // putchar and getchar are in uart.c
  41:main.c        **** FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, uart_getchar, _FDEV_SETUP_RW);
  42:main.c        **** 
  43:main.c        **** #define set_bit(address,bit) (address |= (1<<bit))
  44:main.c        **** #define clear_bit(address,bit) (address &= ~(1<<bit))
  45:main.c        **** #define toggle_bit(address,bit) (address ^= (1<<bit))
  46:main.c        **** 
  47:main.c        **** // This macro is for checking if a certain bit is set in a given register.
  48:main.c        **** // This is useful here for checking the status of individual input pins.
  49:main.c        **** #define check_bit(address,bit) ((address & (1<<bit)) == (1<<bit))
  50:main.c        **** 
  51:main.c        **** int16_t ax = 1;
  52:main.c        **** int16_t ay = 1;
  53:main.c        **** int16_t az = 2;
  54:main.c        **** int16_t gx = 3;
  55:main.c        **** int16_t gy = 4;
  56:main.c        **** int16_t gz = 5;
  57:main.c        **** 
  58:main.c        **** int state = 1;
  59:main.c        **** int stateDebounce = 0;
  60:main.c        **** 
  61:main.c        **** int systemTime = 0;
  62:main.c        **** 
  63:main.c        **** char bluetoothTestChar = 'a';
  64:main.c        **** 
  65:main.c        **** int main(void)
  66:main.c        **** {
  67:main.c        ****     // The following line sets bit 5 high in register DDRD
  68:main.c        ****     // set_bit(DDRD,7); // Pin PD7 is now configured as an OUTPUT
  69:main.c        ****     // set_bit(PORTD,7); // Pin PD7 is now HIGH
  70:main.c        ****     _delay_ms(1000);
  71:main.c        ****     trt_uart_init();
  72:main.c        ****     _delay_ms(500);
  73:main.c        ****     sei();
  74:main.c        ****     _delay_ms(5);
  75:main.c        ****     stdout = stdin = stderr = &uart_str;
  76:main.c        **** 
  77:main.c        ****     mpu6050_init(); // initializes via i2c_init() and then initializes the MPU  
  78:main.c        **** 
  79:main.c        ****     _delay_ms(1000);
  80:main.c        **** 
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** //    fprintf(stdout,"\r\nMCU Restarting . . .\r\n");
  84:main.c        ****     
  85:main.c        ****     while(1)
  86:main.c        ****     {
  87:main.c        **** 
  88:main.c        ****         GetRawDataTest();//stdout
  89:main.c        ****         // if(gx>20000) 
  90:main.c        ****         // {
  91:main.c        ****         //     stateDebounce++;
  92:main.c        **** 
  93:main.c        ****         //     if (stateDebounce > 100)
  94:main.c        ****         //     {  
  95:main.c        ****         //         if(state == 1) 
  96:main.c        ****         //         { 
  97:main.c        ****         //             state = 2;
  98:main.c        ****         //             stateDebounce = 0;
  99:main.c        ****         //         }
 100:main.c        **** 
 101:main.c        ****         //         else
 102:main.c        ****         //         {
 103:main.c        ****         //             state++;
 104:main.c        ****         //             stateDebounce = 0;
 105:main.c        ****         //         }
 106:main.c        ****         //     }
 107:main.c        ****             
 108:main.c        ****         //     // if(state == 'b') state = 'a';
 109:main.c        ****         // }
 110:main.c        **** 
 111:main.c        ****         
 112:main.c        ****         // uart_putchar(bluetoothTestChar, stdout);
 113:main.c        **** 
 114:main.c        ****         _delay_ms(20);
 115:main.c        ****     }
 116:main.c        **** 
 117:main.c        ****     return 0;
 118:main.c        **** }
 119:main.c        **** 
 120:main.c        **** void GetRawDataTest()
 121:main.c        **** {
 2270               		.loc 5 121 0
 2271               		.cfi_startproc
 2272 0952 EF92      		push r14
 2273               	.LCFI101:
 2274               		.cfi_def_cfa_offset 3
 2275               		.cfi_offset 14, -2
 2276 0954 FF92      		push r15
 2277               	.LCFI102:
 2278               		.cfi_def_cfa_offset 4
 2279               		.cfi_offset 15, -3
 2280 0956 0F93      		push r16
 2281               	.LCFI103:
 2282               		.cfi_def_cfa_offset 5
 2283               		.cfi_offset 16, -4
 2284 0958 1F93      		push r17
 2285               	.LCFI104:
 2286               		.cfi_def_cfa_offset 6
 2287               		.cfi_offset 17, -5
 2288 095a CF93      		push r28
 2289               	.LCFI105:
 2290               		.cfi_def_cfa_offset 7
 2291               		.cfi_offset 28, -6
 2292 095c DF93      		push r29
 2293               	.LCFI106:
 2294               		.cfi_def_cfa_offset 8
 2295               		.cfi_offset 29, -7
 2296 095e CDB7      		in r28,__SP_L__
 2297 0960 DEB7      		in r29,__SP_H__
 2298               	.LCFI107:
 2299               		.cfi_def_cfa_register 28
 2300 0962 2A97      		sbiw r28,10
 2301               	.LCFI108:
 2302               		.cfi_def_cfa_offset 18
 2303 0964 0FB6      		in __tmp_reg__,__SREG__
 2304 0966 F894      		cli
 2305 0968 DEBF      		out __SP_H__,r29
 2306 096a 0FBE      		out __SREG__,__tmp_reg__
 2307 096c CDBF      		out __SP_L__,r28
 2308               	/* prologue: function */
 2309               	/* frame size = 10 */
 2310               	/* stack size = 16 */
 2311               	.L__stack_usage = 16
 122:main.c        **** 
 123:main.c        ****     toggle_bit(PORTD,7); // PD5 switches from LOW to HIGH or vice vers
 2312               		.loc 5 123 0
 2313 096e 8BB1      		in r24,0xb
 2314 0970 8058      		subi r24,lo8(-(-128))
 2315 0972 8BB9      		out 0xb,r24
 124:main.c        ****     mpu6050_getRawData(&ax, &ay, &az, &gx, &gy, &gz);
 2316               		.loc 5 124 0
 2317 0974 90E0      		ldi r25,lo8(gz)
 2318 0976 E92E      		mov r14,r25
 2319 0978 90E0      		ldi r25,hi8(gz)
 2320 097a F92E      		mov r15,r25
 2321 097c 00E0      		ldi r16,lo8(gy)
 2322 097e 10E0      		ldi r17,hi8(gy)
 2323 0980 20E0      		ldi r18,lo8(gx)
 2324 0982 30E0      		ldi r19,hi8(gx)
 2325 0984 40E0      		ldi r20,lo8(az)
 2326 0986 50E0      		ldi r21,hi8(az)
 2327 0988 60E0      		ldi r22,lo8(ay)
 2328 098a 70E0      		ldi r23,hi8(ay)
 2329 098c 80E0      		ldi r24,lo8(ax)
 2330 098e 90E0      		ldi r25,hi8(ax)
 2331 0990 0E94 0000 		call mpu6050_getRawData
 2332               	.LVL193:
 125:main.c        ****     char itemp[10];
 126:main.c        **** 
 127:main.c        ****     ltoa(ax,itemp,10);
 2333               		.loc 5 127 0
 2334 0994 6091 0000 		lds r22,ax
 2335 0998 7091 0000 		lds r23,ax+1
 2336 099c 8827      		clr r24
 2337 099e 77FD      		sbrc r23,7
 2338 09a0 8095      		com r24
 2339 09a2 982F      		mov r25,r24
 2340 09a4 2AE0      		ldi r18,lo8(10)
 2341 09a6 30E0      		ldi r19,0
 2342 09a8 AE01      		movw r20,r28
 2343 09aa 4F5F      		subi r20,-1
 2344 09ac 5F4F      		sbci r21,-1
 2345 09ae 0E94 0000 		call ltoa
 2346               	.LVL194:
 128:main.c        ****     uart_puts(itemp);
 2347               		.loc 5 128 0
 2348 09b2 CE01      		movw r24,r28
 2349 09b4 0196      		adiw r24,1
 2350 09b6 0E94 0000 		call uart_puts
 2351               	.LVL195:
 129:main.c        ****     uart_putchar(' ', stdout);
 2352               		.loc 5 129 0
 2353 09ba 00E0      		ldi r16,lo8(__iob+2)
 2354 09bc 10E0      		ldi r17,hi8(__iob+2)
 2355 09be F801      		movw r30,r16
 2356 09c0 6081      		ld r22,Z
 2357 09c2 7181      		ldd r23,Z+1
 2358 09c4 80E2      		ldi r24,lo8(32)
 2359 09c6 0E94 0000 		call uart_putchar
 2360               	.LVL196:
 130:main.c        **** 
 131:main.c        **** 
 132:main.c        ****     ltoa(ay,itemp,10);
 2361               		.loc 5 132 0
 2362 09ca 6091 0000 		lds r22,ay
 2363 09ce 7091 0000 		lds r23,ay+1
 2364 09d2 8827      		clr r24
 2365 09d4 77FD      		sbrc r23,7
 2366 09d6 8095      		com r24
 2367 09d8 982F      		mov r25,r24
 2368 09da 2AE0      		ldi r18,lo8(10)
 2369 09dc 30E0      		ldi r19,0
 2370 09de AE01      		movw r20,r28
 2371 09e0 4F5F      		subi r20,-1
 2372 09e2 5F4F      		sbci r21,-1
 2373 09e4 0E94 0000 		call ltoa
 2374               	.LVL197:
 133:main.c        ****     uart_puts(itemp);
 2375               		.loc 5 133 0
 2376 09e8 CE01      		movw r24,r28
 2377 09ea 0196      		adiw r24,1
 2378 09ec 0E94 0000 		call uart_puts
 2379               	.LVL198:
 134:main.c        ****     uart_putchar(' ', stdout);
 2380               		.loc 5 134 0
 2381 09f0 F801      		movw r30,r16
 2382 09f2 6081      		ld r22,Z
 2383 09f4 7181      		ldd r23,Z+1
 2384 09f6 80E2      		ldi r24,lo8(32)
 2385 09f8 0E94 0000 		call uart_putchar
 2386               	.LVL199:
 135:main.c        **** 
 136:main.c        ****     ltoa(az,itemp,10);
 2387               		.loc 5 136 0
 2388 09fc 6091 0000 		lds r22,az
 2389 0a00 7091 0000 		lds r23,az+1
 2390 0a04 8827      		clr r24
 2391 0a06 77FD      		sbrc r23,7
 2392 0a08 8095      		com r24
 2393 0a0a 982F      		mov r25,r24
 2394 0a0c 2AE0      		ldi r18,lo8(10)
 2395 0a0e 30E0      		ldi r19,0
 2396 0a10 AE01      		movw r20,r28
 2397 0a12 4F5F      		subi r20,-1
 2398 0a14 5F4F      		sbci r21,-1
 2399 0a16 0E94 0000 		call ltoa
 2400               	.LVL200:
 137:main.c        ****     uart_puts(itemp);
 2401               		.loc 5 137 0
 2402 0a1a CE01      		movw r24,r28
 2403 0a1c 0196      		adiw r24,1
 2404 0a1e 0E94 0000 		call uart_puts
 2405               	.LVL201:
 138:main.c        ****     uart_putchar(' ', stdout);
 2406               		.loc 5 138 0
 2407 0a22 F801      		movw r30,r16
 2408 0a24 6081      		ld r22,Z
 2409 0a26 7181      		ldd r23,Z+1
 2410 0a28 80E2      		ldi r24,lo8(32)
 2411 0a2a 0E94 0000 		call uart_putchar
 2412               	.LVL202:
 139:main.c        **** 
 140:main.c        ****     ltoa(gy,itemp,10);
 2413               		.loc 5 140 0
 2414 0a2e 6091 0000 		lds r22,gy
 2415 0a32 7091 0000 		lds r23,gy+1
 2416 0a36 8827      		clr r24
 2417 0a38 77FD      		sbrc r23,7
 2418 0a3a 8095      		com r24
 2419 0a3c 982F      		mov r25,r24
 2420 0a3e 2AE0      		ldi r18,lo8(10)
 2421 0a40 30E0      		ldi r19,0
 2422 0a42 AE01      		movw r20,r28
 2423 0a44 4F5F      		subi r20,-1
 2424 0a46 5F4F      		sbci r21,-1
 2425 0a48 0E94 0000 		call ltoa
 2426               	.LVL203:
 141:main.c        ****     uart_puts(itemp);
 2427               		.loc 5 141 0
 2428 0a4c CE01      		movw r24,r28
 2429 0a4e 0196      		adiw r24,1
 2430 0a50 0E94 0000 		call uart_puts
 2431               	.LVL204:
 142:main.c        ****     uart_putchar(' ', stdout);
 2432               		.loc 5 142 0
 2433 0a54 F801      		movw r30,r16
 2434 0a56 6081      		ld r22,Z
 2435 0a58 7181      		ldd r23,Z+1
 2436 0a5a 80E2      		ldi r24,lo8(32)
 2437 0a5c 0E94 0000 		call uart_putchar
 2438               	.LVL205:
 143:main.c        **** 
 144:main.c        **** /*    ltoa(gy,itemp,10);
 145:main.c        ****     uart_puts(itemp);
 146:main.c        ****     uart_putchar(' ', stdout);
 147:main.c        **** 
 148:main.c        ****     ltoa(gz,itemp,10);
 149:main.c        ****     uart_puts(itemp);
 150:main.c        ****     uart_putchar(' ', stdout);
 151:main.c        **** 
 152:main.c        **** */    
 153:main.c        ****     uart_putchar('\n', stdout);
 2439               		.loc 5 153 0
 2440 0a60 F801      		movw r30,r16
 2441 0a62 6081      		ld r22,Z
 2442 0a64 7181      		ldd r23,Z+1
 2443 0a66 8AE0      		ldi r24,lo8(10)
 2444 0a68 0E94 0000 		call uart_putchar
 2445               	.LVL206:
 2446               	/* epilogue start */
 154:main.c        **** 
 155:main.c        **** 
 156:main.c        **** /*    (gx,itemp,10);
 157:main.c        ****     fputs(itemp,stdout);
 158:main.c        ****     fputc(' ', stdout);*/
 159:main.c        **** 
 160:main.c        **** 
 161:main.c        **** 
 162:main.c        **** 
 163:main.c        **** /*    sprintf(stdout," LOOOLS  ");
 164:main.c        **** 
 165:main.c        **** 
 166:main.c        ****     char itmp[10];
 167:main.c        ****     ltoa(ax,itmp,10); 
 168:main.c        **** */    // uart_putchar(' ',stdout); 
 169:main.c        ****     // uart_putchar('A',stdout);
 170:main.c        ****     // fprintf(stdout, "%d %d %d %d %d %d %d\n", ax, ay, az, gx, gy, gz, state);
 171:main.c        ****     // _delay_ms(10);
 172:main.c        **** }
 2447               		.loc 5 172 0
 2448 0a6c 2A96      		adiw r28,10
 2449 0a6e 0FB6      		in __tmp_reg__,__SREG__
 2450 0a70 F894      		cli
 2451 0a72 DEBF      		out __SP_H__,r29
 2452 0a74 0FBE      		out __SREG__,__tmp_reg__
 2453 0a76 CDBF      		out __SP_L__,r28
 2454 0a78 DF91      		pop r29
 2455 0a7a CF91      		pop r28
 2456 0a7c 1F91      		pop r17
 2457 0a7e 0F91      		pop r16
 2458 0a80 FF90      		pop r15
 2459 0a82 EF90      		pop r14
 2460 0a84 0895      		ret
 2461               		.cfi_endproc
 2462               	.LFE37:
 2464               		.section	.text.startup,"ax",@progbits
 2465               	.global	main
 2467               	main:
 2468               	.LFB36:
  66:main.c        **** {
 2469               		.loc 5 66 0
 2470               		.cfi_startproc
 2471               	/* prologue: function */
 2472               	/* frame size = 0 */
 2473               	/* stack size = 0 */
 2474               	.L__stack_usage = 0
 2475               	.LVL207:
 2476               	.LBB60:
 2477               	.LBB61:
 164:/opt/local/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2478               		.loc 4 164 0
 2479 0000 2FEF      		ldi r18,lo8(1599999)
 2480 0002 89E6      		ldi r24,hi8(1599999)
 2481 0004 98E1      		ldi r25,hlo8(1599999)
 2482 0006 2150      		1: subi r18,1
 2483 0008 8040      		sbci r24,0
 2484 000a 9040      		sbci r25,0
 2485 000c 01F4      		brne 1b
 2486 000e 00C0      		rjmp .
 2487 0010 0000      		nop
 2488               	.LBE61:
 2489               	.LBE60:
  71:main.c        ****     trt_uart_init();
 2490               		.loc 5 71 0
 2491 0012 0E94 0000 		call trt_uart_init
 2492               	.LVL208:
 2493               	.LBB62:
 2494               	.LBB63:
 164:/opt/local/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2495               		.loc 4 164 0
 2496 0016 2FEF      		ldi r18,lo8(799999)
 2497 0018 84E3      		ldi r24,hi8(799999)
 2498 001a 9CE0      		ldi r25,hlo8(799999)
 2499 001c 2150      		1: subi r18,1
 2500 001e 8040      		sbci r24,0
 2501 0020 9040      		sbci r25,0
 2502 0022 01F4      		brne 1b
 2503 0024 00C0      		rjmp .
 2504 0026 0000      		nop
 2505               	.LBE63:
 2506               	.LBE62:
  73:main.c        ****     sei();
 2507               		.loc 5 73 0
 2508               	/* #APP */
 2509               	 ;  73 "main.c" 1
 2510 0028 7894      		sei
 2511               	 ;  0 "" 2
 2512               	.LVL209:
 2513               	/* #NOAPP */
 2514               	.LBB64:
 2515               	.LBB65:
 164:/opt/local/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2516               		.loc 4 164 0
 2517 002a 8FE0      		ldi r24,lo8(9999)
 2518 002c 97E2      		ldi r25,hi8(9999)
 2519 002e 0197      		1: sbiw r24,1
 2520 0030 01F4      		brne 1b
 2521 0032 00C0      		rjmp .
 2522 0034 0000      		nop
 2523               	.LBE65:
 2524               	.LBE64:
  75:main.c        ****     stdout = stdin = stderr = &uart_str;
 2525               		.loc 5 75 0
 2526 0036 80E0      		ldi r24,lo8(uart_str)
 2527 0038 90E0      		ldi r25,hi8(uart_str)
 2528 003a 9093 0000 		sts __iob+4+1,r25
 2529 003e 8093 0000 		sts __iob+4,r24
 2530 0042 9093 0000 		sts __iob+1,r25
 2531 0046 8093 0000 		sts __iob,r24
 2532 004a 9093 0000 		sts __iob+2+1,r25
 2533 004e 8093 0000 		sts __iob+2,r24
  77:main.c        ****     mpu6050_init(); // initializes via i2c_init() and then initializes the MPU  
 2534               		.loc 5 77 0
 2535 0052 0E94 0000 		call mpu6050_init
 2536               	.LVL210:
 2537               	.LBB66:
 2538               	.LBB67:
 164:/opt/local/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2539               		.loc 4 164 0
 2540 0056 9FEF      		ldi r25,lo8(1599999)
 2541 0058 29E6      		ldi r18,hi8(1599999)
 2542 005a 88E1      		ldi r24,hlo8(1599999)
 2543 005c 9150      		1: subi r25,1
 2544 005e 2040      		sbci r18,0
 2545 0060 8040      		sbci r24,0
 2546 0062 01F4      		brne 1b
 2547               	.L149:
 2548 0064 00C0      		rjmp .
 2549 0066 0000      		nop
 2550               	.LBE67:
 2551               	.LBE66:
 2552               	.LBB68:
  88:main.c        ****         GetRawDataTest();//stdout
 2553               		.loc 5 88 0
 2554 0068 0E94 0000 		call GetRawDataTest
 2555               	.LVL211:
 2556               	.LBB69:
 2557               	.LBB70:
 164:/opt/local/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2558               		.loc 4 164 0
 2559 006c 8FE3      		ldi r24,lo8(-25537)
 2560 006e 9CE9      		ldi r25,hi8(-25537)
 2561 0070 0197      		1: sbiw r24,1
 2562 0072 01F4      		brne 1b
 2563 0074 00C0      		rjmp .L149
 2564               	.LBE70:
 2565               	.LBE69:
 2566               	.LBE68:
 2567               		.cfi_endproc
 2568               	.LFE36:
 2570               		.local	b.2098
 2571               		.comm	b.2098,80,1
 2572               		.local	rxp.2099
 2573               		.comm	rxp.2099,2,1
 2574               	.global	bluetoothTestChar
 2575               		.data
 2578               	bluetoothTestChar:
 2579 0000 61        		.byte	97
 2580               	.global	systemTime
 2581               		.section .bss
 2584               	systemTime:
 2585 0000 0000      		.zero	2
 2586               	.global	stateDebounce
 2589               	stateDebounce:
 2590 0002 0000      		.zero	2
 2591               	.global	state
 2592               		.data
 2595               	state:
 2596 0001 0100      		.word	1
 2597               	.global	gz
 2600               	gz:
 2601 0003 0500      		.word	5
 2602               	.global	gy
 2605               	gy:
 2606 0005 0400      		.word	4
 2607               	.global	gx
 2610               	gx:
 2611 0007 0300      		.word	3
 2612               	.global	az
 2615               	az:
 2616 0009 0200      		.word	2
 2617               	.global	ay
 2620               	ay:
 2621 000b 0100      		.word	1
 2622               	.global	ax
 2625               	ax:
 2626 000d 0100      		.word	1
 2627               	.global	uart_str
 2630               	uart_str:
 2631 000f 0000 00   		.zero	3
 2632 0012 03        		.byte	3
 2633 0013 0000 0000 		.zero	4
 2634 0017 0000      		.word	gs(uart_putchar)
 2635 0019 0000      		.word	gs(uart_getchar)
 2636 001b 0000      		.word	0
 2637               		.comm	buffer,14,1
 2638               		.comm	trt_rx_c,1,1
 2639               		.local	tx_buff
 2640               		.comm	tx_buff,200,1
 2641               		.local	tx_out
 2642               		.comm	tx_out,2,1
 2643               		.local	tx_in
 2644               		.comm	tx_in,2,1
 2645               		.text
 2646               	.Letext0:
 2647               		.file 6 "/opt/local/avr/include/stdint.h"
 2648               		.file 7 "/opt/local/avr/include/stdio.h"
 2649               		.file 8 "/opt/local/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:4      *ABS*:000000000000003f __SREG__
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:12     .text:0000000000000000 uart_putchar
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2642   .bss:0000000000000120 tx_in
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2573   .bss:0000000000000056 tx_buff
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2640   .bss:000000000000011e tx_out
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:86     .text:0000000000000058 uart_getchar
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2571   .bss:0000000000000054 rxp.2099
                             .bss:0000000000000004 b.2098
                            *COM*:0000000000000001 trt_rx_c
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:398    .text:00000000000001ec trt_uart_init
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:430    .text:0000000000000212 __vector_26
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:528    .text:000000000000029a uart_puts
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:573    .text:00000000000002ba __vector_25
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:612    .text:00000000000002da i2c_init
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:632    .text:00000000000002e6 i2c_start
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:705    .text:000000000000032c i2c_start_wait
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:777    .text:000000000000037a i2c_rep_start
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:794    .text:000000000000037e i2c_stop
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:818    .text:000000000000038e i2c_write
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:857    .text:00000000000003b0 i2c_readAck
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:882    .text:00000000000003c4 i2c_readNak
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:906    .text:00000000000003d8 mpu6050_readBytes.part.1
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1054   .text:000000000000046a mpu6050_readBytes
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1077   .text:0000000000000474 mpu6050_readByte
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1101   .text:000000000000047c mpu6050_writeBytes
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1217   .text:00000000000004ea mpu6050_writeByte
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1261   .text:000000000000050a mpu6050_writeBits.part.2
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1383   .text:000000000000058a mpu6050_readBits
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1502   .text:0000000000000602 mpu6050_readBit
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1576   .text:0000000000000642 mpu6050_writeBits
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1596   .text:000000000000064a mpu6050_writeBit
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1684   .text:00000000000006a0 mpu6050_setSleepDisabled
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1703   .text:00000000000006aa mpu6050_setSleepEnabled
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1722   .text:00000000000006b4 mpu6050_testConnection
                            *COM*:000000000000000e buffer
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1739   .text:00000000000006ba mpu6050_init
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1813   .text:0000000000000702 mpu6050_getRawData
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:1960   .text:00000000000007b2 mpu6050_getConvData
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2267   .text:0000000000000952 GetRawDataTest
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2600   .data:0000000000000003 gz
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2605   .data:0000000000000005 gy
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2610   .data:0000000000000007 gx
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2615   .data:0000000000000009 az
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2620   .data:000000000000000b ay
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2625   .data:000000000000000d ax
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2467   .text.startup:0000000000000000 main
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2630   .data:000000000000000f uart_str
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2578   .data:0000000000000000 bluetoothTestChar
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2584   .bss:0000000000000000 systemTime
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2589   .bss:0000000000000002 stateDebounce
/var/folders/67/ww4hhkks68vc_5sncbvp519m0000gn/T//cc0Mp8Fh.s:2595   .data:0000000000000001 state

UNDEFINED SYMBOLS
__iob
__floatsisf
__mulsf3
__divsf3
ltoa
__do_copy_data
__do_clear_bss
